これで、前の章で説明した構造体とオブジェクトをすべて組み合わせて、グラフィックパイプラインを作成することができるようになりました。簡単にまとめると、今まで出てきた（パイプライン関連の）オブジェクトの種類は以下の通りです。

* シェーダステージ：グラフィックスパイプラインのプログラマブルステージの機能を定義するシェーダモジュール。
* fixed-functionの状態：インプットアセンブリ、ラスタライザ、ビューポート、カラーブレンディングなど、パイプラインのfixed-cunctionステージを定義するすべての構造体
* パイプラインレイアウト：シェーダが参照するユニフォーム値とプッシュ値で、描画時に更新することができる
* レンダーパス： パイプラインステージで参照されるアタッチメントとその使い方

これらを組み合わせによりグラフィックスパイプラインの機能は完全に定義されているので、`createGraphicsPipeline` 関数の最後にある `VkGraphicsPipelineCreateInfo` 構造体を埋めましょう。しかし、`vkDestroyShaderModule` の呼び出しの前にしてください。なぜなら、シェーダモジュールはまだ作成に使うからです。

```c++
VkGraphicsPipelineCreateInfo pipelineInfo{};
pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
pipelineInfo.stageCount = 2;
pipelineInfo.pStages = shaderStages;
```

まず、`VkPipelineShaderStageCreateInfo` 構造体の配列を参照します。

```c++
pipelineInfo.pVertexInputState = &vertexInputInfo;
pipelineInfo.pInputAssemblyState = &inputAssembly;
pipelineInfo.pViewportState = &viewportState;
pipelineInfo.pRasterizationState = &rasterizer;
pipelineInfo.pMultisampleState = &multisampling;
pipelineInfo.pDepthStencilState = nullptr; // Optional
pipelineInfo.pColorBlendState = &colorBlending;
pipelineInfo.pDynamicState = nullptr; // Optional
```

そして、fixed-functionステージを記述する全ての構造を参照します。

```c++
pipelineInfo.layout = pipelineLayout;
```

その後はパイプラインのレイアウトです。これは構造体ポインタではなくVulkanのハンドルです。

```c++
pipelineInfo.renderPass = renderPass;
pipelineInfo.subpass = 0;
```

最後に、レンダーパスへの参照と、このグラフィックスパイプラインが使用されるサブパスのインデックスを指定します。この特定のインスタンスの代わりに他のレンダーパスをこのパイプラインで使用することも可能ですが、`renderPass`と*互換性*がなければなりません。互換性の要件については[ここ](https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility)で説明されていますが、このチュートリアルではこの機能は使用しません。

```c++
pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; // Optional
pipelineInfo.basePipelineIndex = -1; // Optional
```

実際には、さらに2つのパラメータがあります。`basePipelineHandle` と `basePipelineIndex` です。Vulkanでは、既存のパイプラインから派生した新しいグラフィックスパイプラインを作成することができます。パイプライン派生によって、パイプラインが既存のパイプラインと共通の機能を多く持っている場合には、パイプラインのセットアップにかかるコストが少なくて済み、同じ親から派生したパイプライン間の切り替えが迅速に行えるます。既存のパイプラインのハンドルを `basePipelineHandle` で指定するか、`basePipelineIndex` で今一緒に作成されようとしている別のパイプラインをインデックスで参照することができます。今のところパイプラインは一つしかないので、単純にヌルのハンドルと無効なインデックスを指定します。これらの値は、`VkGraphicsPipelineCreateInfo`の`flags`フィールドに `VK_PIPELINE_CREATE_DERIVATIVE_BIT` フラグが指定されている場合にのみ使用されます。

最後のステップとして、`VkPipeline` オブジェクトを保持するクラスメンバを作成します。

```c++
VkPipeline graphicsPipeline;
```

そして最後にグラフィックパイプラインを作成します。

```c++
if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &graphicsPipeline) != VK_SUCCESS) {
    throw std::runtime_error("failed to create graphics pipeline!");
}
```

関数 `vkCreateGraphicsPipelines` は実際には Vulkan の通常のオブジェクト作成関数よりも多くのパラメータを持っています。これは複数の `VkGraphicsPipelineCreateInfo` オブジェクトを受け取り、1回の呼び出しで複数の `VkPipeline` オブジェクトを作成するように設計されているためです。

`VK_NULL_HANDLE` を渡した2番目のパラメータは 、オプションの `VkPipelineCache` オブジェクトを参照するためのものです。パイプラインキャッシュは、`vkCreateGraphicsPipelines` を複数回呼び出した際にパイプライン作成に関連するデータを保存して再利用するために利用することができ、キャッシュがファイルに保存されている場合はプログラムの実行中にも利用することができます。これにより、後のパイプライン作成を大幅に高速化することが可能になります。これについてはパイプラインキャッシュの章で説明します。

グラフィックスパイプラインは、一般的な描画操作のすべてに必要とされるので、プログラムの最後に破棄します。

```c++
void cleanup() {
    vkDestroyPipeline(device, graphicsPipeline, nullptr);
    vkDestroyPipelineLayout(device, pipelineLayout, nullptr);
    ...
}
```

さて、プログラムを実行して、これまでの苦労によりついにパイプラインの作成が成功したことを確認してください。すでに、画面上に何かが表示されるのが見えてきました。次のいくつかの章で、スワップチェーンイメージから実際のフレームバッファをセットアップし、描画コマンドを準備します。

[C++ コード](/code/12_graphics_pipeline_complete.cpp) /
[頂点シェーダ](/code/09_shader_base.vert) /
[フラグメントシェーダ](/code/09_shader_base.frag)
