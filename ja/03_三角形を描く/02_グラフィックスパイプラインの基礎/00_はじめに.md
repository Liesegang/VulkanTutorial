次のいくつかの章では、最初の三角形を描画するために設定されたグラフィックパイプラインをセットアップしていきます。グラフィックスパイプラインとは、メッシュの頂点とテクスチャを受け取り、レンダリングターゲットのピクセルを生成するまでの一連の操作のことです。簡単な概要を以下に示します。

![](/images/vulkan_simplified_pipeline.svg)

*入力アセンブラ*は、指定したバッファから生の頂点データを収集します。インデックスバッファを使用して、頂点データ自体を複製することなく特定の要素を繰り返すこともできます。

*頂点シェーダ*は頂点ごとに実行され、一般的には頂点の位置をモデル空間からスクリーン空間に変換します。また、頂点ごとのデータをパイプラインに渡します。

*テッセレーションシェーダ*を使用すると、特定のルールに基づいてジオメトリを細分化し、メッシュの品質を向上させることができます。これは、例えばレンガの壁や階段のようなサーフェスを近くで見たときに、平らでないように見えるようにするためによく使用されます。

*ジオメトリシェーダ*は、すべてのプリミティブ（三角形、線、点）に対して実行され、それを破棄したり、入ってきたプリミティブよりも多くのプリミティブを出力したりすることができます。これはテッセレーションシェーダに似ていますが、より柔軟性があります。しかし、Intelの統合GPUを除いてほとんどのグラフィックスカードでは性能があまり良くないため、現在のアプリケーションではあまり使われていません。

*ラスタライズ*ステージでは、プリミティブを*フラグメント*に分割します。これらは、フレームバッファ上を埋めるピクセル要素です。画面外に出たフラグメントはすべて破棄され、図のように、頂点シェーダによって出力されたアトリビュートがフラグメント間で補間されます。通常、他のプリミティブフラグメントの後ろにあるフラグメントも、デプステストによりここで破棄されます。

*フラグメントシェーダ*は、生き残ったすべてのフラグメントに対して実行され、フラグメントがどのフレームバッファに書き込まれ、どの色とデプス値で書かれているかを決定します。これは、頂点シェーダから補間されたデータを使って行うことができ、テクスチャ座標やライティングの法線のようなものを含むことができます。

*カラーブレンディング*ステージでは、フレームバッファ内の同じピクセルにマップされた異なるフラグメントを混合する操作を適用します。フラグメントは、単純にお互いを上書きしたり、加算したり、透明度に基づいて混合したりすることができます。

図の緑色のステージは *fixed-function* ステージとして知られています。これらのステージは、パラメータを使って動作を微調整することができますが、動作方法は事前に定義されています。

一方、図のオレンジ色のステージは *programmable* と呼ばれるもので、自分のコードをグラフィックスカードにアップロードして、好きなように操作を実行することができます。これにより、例えばフラグメントシェーダを使用して、テクスチャリングやライティングからレイトレースまで、何でも実装することができます。これらのプログラムは、多数の GPU コア上で同時に実行され、頂点やフラグメントのような多数のオブジェクトを並列に処理します。

以前にOpenGLやDirect3Dのような古いAPIを使っていた場合、`glBlendFunc`や`OMSetBlendState`のような呼び出しでパイプラインの設定を自由に変更できることに慣れているでしょう。Vulkanのグラフィックスパイプラインはほとんど完全に不変なので、シェーダを変更したり、異なるフレームバッファをバインドしたり、ブレンド関数を変更したりしたい場合は、パイプラインを一から作り直さなければなりません。欠点は、レンダリング操作で使用したい状態のさまざまな組み合わせをすべて表現するパイプラインをいくつも作成しなければならないことです。しかし、パイプラインで行うすべての操作が事前にわかっているため、ドライバはそれに合わせてよりうまく最適化することができます。

プログラマブルなステージの中には、やることに応じてオプションであるものもあります。例えば、単純なジオメトリを描くだけの場合は、テッセレーションとジオメトリのステージを無効にすることができます。デプス値にしか興味がない場合は、[シャドウマップ](https://en.wikipedia.org/wiki/Shadow_mapping)の生成に便利なフラグメントシェーダステージを無効にすることができます。

次の章では、まず、三角形を画面に表示するために必要な 2 つのプログラマブルなステージである、頂点シェーダとフラグメントシェーダを作成します。ブレンドモード、ビューポート、ラスタライズなどの fixed-function の設定は、その後の章で行います。Vulkanでグラフィックスパイプラインの設定の最後の部分は、入力と出力のフレームバッファを指定することです。

`createGraphicsPipeline`を作成し`initVulkan`の`createImageViews`の直後に呼び出してください。この関数については、次の章で説明します。

```c++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createGraphicsPipeline();
}

...

void createGraphicsPipeline() {

}
```

[C++ コード](/code/08_graphics_pipeline.cpp)
