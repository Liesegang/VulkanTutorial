以前のAPIとは異なり、Vulkanのシェーダコードは、[GLSL](https://ja.wikipedia.org/wiki/GLSL)や[HLSL](https://ja.wikipedia.org/wiki/High_Level_Shading_Language)のような人間が読める構文ではなく、バイトコード形式で指定する必要があります。このバイトコード形式は [SPIR-V](https://www.khronos.org/spir) と呼ばれ、Vulkan と OpenCL (Khronos API) の両方で使用できるように設計されています。グラフィックスシェーダやコンピュートシェーダの記述に使用できるフォーマットですが、このチュートリアルではVulkanのグラフィックスパイプラインで使用されるシェーダに焦点を当てていきます。

バイトコード形式を使うメリットは、シェーダコードをネイティブコードに変換するためのGPUベンダが書いたコンパイラの複雑さが格段に少ないことです。過去には、GLSLのような人間が読める構文では、一部のGPUベンダーは標準の解釈にかなり柔軟性があることが示されていました。このようなベンダの GPU を使用して、たまたま手の込んだシェーダを書いた場合、他のベンダのドライバがシンタックスエラーのためにコードを拒否したり、コンパイラのバグのためにシェーダの動作がおかしくなったりする危険性があります。SPIR-V のような素直なバイトコードフォーマットであれば、このような事態は避けられます。

しかし、だからといって、このバイトコードを手書きで書かなければならないということではありません。Khronos は、GLSL を SPIR-V にコンパイルするベンダに依存しないコンパイラをリリースしました。このコンパイラは、シェーダコードが標準に完全に準拠しているかどうかを検証するために設計されており、プログラムに同梱できる SPIR-V バイナリを生成します。このコンパイラをライブラリとしてインクルードして実行時に SPIR-V を生成することもできますが、このチュートリアルではそのようなことはしません。このコンパイラは `glslangValidator.exe` で直接使うこともできますが、代わりに Google の `glslc.exe` を使います。`glslc`の利点は、GCCやClangのようなよく知られたコンパイラと同じパラメータフォーマットを使っていることと、*includes*のような追加機能が含まれていることです。どちらもすでにVulkan SDKに含まれているので、余分なものをダウンロードする必要はありません。

GLSLはCスタイルの構文を持つシェーディング言語です。GLSLで書かれたプログラムは、オブジェクトごとに呼び出される`main`関数を持っています。GLSLは入力にパラメータを使用し、出力に戻り値を使用する代わりに、グローバル変数を使用して入力と出力を処理します。この言語には、組み込みのベクトルや行列プリミティブなど、グラフィックスプログラミングを支援する多くの機能が含まれています。クロス積、行列-ベクトル積、ベクトルの周りの反射などの演算のための関数が含まれています。ベクトルの型は `vec` と呼ばれ、要素の数を表す数字があとに付きます。例えば、3次元の位置は `vec3` に格納されます。`.x` のようなメンバを使って単一の要素にアクセスすることもでますし、複数の要素から同時に指定して新しいベクトルを作成することも可能である。例えば、`vec3(1.0, 2.0, 3.0).xy` という式は `vec2` となります。ベクトルのコンストラクタは、ベクトルオブジェクトとスカラ値の組み合わせを取ることもできます。例えば、`vec3` は `vec3(vec2(1.0, 2.0), 3.0)` で構築できます。

前章で述べたように、画面上の三角形を表示するためには頂点シェーダとフラグメントシェーダを書く必要があります。次の２つのセクションでは、それぞれのシェーダのためのGLSLコードを説明し、その後、SPIR-Vのバイナリを２つ作成してプログラムにロードする方法を紹介します。

## 頂点シェーダ

頂点シェーダは、入力された各頂点を処理します。入力として、ワールドポジション、色、法線、テクスチャ座標などのアトリビュートを受け取ります。出力はクリップ座標での最終的なポジションと、フラグメントシェーダに渡す必要がある色やテクスチャ座標などのアトリビュートです。これらの値は、滑らかなグラデーションを生成するためにラスタライザによってフラグメント上に補間されます。

*クリップ座標*は、頂点シェーダから出力される4次元ベクトルで、その後、ベクトル全体をその最後の成分で割ることで、*正規化されたデバイス座標*に変換されます。これらの正規化されたデバイス座標は、フレームバッファを以下のような [-1, 1] x [-1, 1] の座標系にマッピングする[同次座標](http://www.eli.hokkai-s-u.ac.jp/~kikuchi/ma2/chap10a.html)です。

![](/images/normalized_device_coordinates.svg)

以前にコンピュータグラフィックスに触れたことがある人は、これらのことにすでに精通しているはずです。もしあなたが以前にOpenGLを使ったことがあるなら、Y座標の符号が反転していることに気づくでしょう。Z 座標は、Direct3D と同じ 0 から 1 までの範囲を使用するようになりました。

最初の三角形には何も変換はしませんが、3つの頂点の位置を直接正規化されたデバイス座標として指定して、次のような形状を作成します。

![](/images/triangle_coordinates.svg)

頂点シェーダから最後の要素を `1` に設定したベクトルをクリップ座標として出力することで、正規化されたデバイス座標を直接出力することができます。そうすれば、クリップ座標を正規化されたデバイス座標に変換するための除算をしても何も変化しません。

本来ならばこれらの座標は頂点バッファに格納されるはずですが、Vulkanで頂点バッファを作成してデータを充填するのは簡単ではありません。そのため、三角形が画面上に表示されるのを見て満足するまで、これは先延ばしにすることにしました。それまではちょっと変わったことをしようと思っています。つまり、頂点シェーダの中に直接座標を入れるのです。コードは次のようになります。

```glsl
#version 450

vec2 positions[3] = vec2[](
    vec2(0.0, -0.5),
    vec2(0.5, 0.5),
    vec2(-0.5, 0.5)
);

void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
}
```

`main` 関数が各頂点ごとに呼び出されます。組み込みの `gl_VertexIndex` 変数には、現在の頂点のインデックスが格納されています。これは通常は頂点バッファへのインデックスですが、ここではハードコードされた頂点データの配列へのインデックスになります。各頂点の位置はシェーダの定数配列から取得され、ダミーの `z` と `w` コンポーネントと組み合わされて、クリップ座標の位置を生成します。組み込みの変数 `gl_Position` を使って出力します。

## フラグメントシェーダ

頂点シェーダからの位置によって作られる三角形は、画面上の領域をフラグメントで埋め尽くします。フラグメントシェーダは、これらのフラグメントに対して呼び出され、1つのフレームバッファ（または複数のフレームバッファ）の色とデプスを生成します。三角形全体の色を赤で出力する単純なフラグメントシェーダは次のようになります。

```glsl
#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(location = 0) out vec4 outColor;

void main() {
    outColor = vec4(1.0, 0.0, 0.0, 1.0);
}
```

頂点シェーダの `main` 関数がすべての頂点に対して呼び出されるのと同じように、`main` 関数はすべてのフラグメントに対して呼び出されます。GLSLの色は、[0, 1]の範囲の値のR、G、B、アルファチャンネルによる4成分ベクトルです。頂点シェーダの `gl_Position` とは異なり、現在のフラグメントの色を出力するための組み込み変数はありません。フレームバッファごとに独自の出力変数を指定する必要があり、`layout(location = 0)`修飾子はフレームバッファのインデックスを指定します。赤色はこの `outColor` 変数に書き込まれ、インデックス `0` の最初の (そして唯一の) フレームバッファにリンクされます。

## 各頂点の色

三角形全体を赤くするのはあまり面白くありません。次のような見た目のほうがずっと良くないですか？

![](/images/triangle_coordinates_colors.png)

これを実現するには、両方のシェーダにいくつかの変更を加えなければなりません。まず、3 つの頂点それぞれに異なる色を指定する必要があります。位置を指定したときと同じ様に、頂点シェーダに色を含む配列を追加します。

```glsl
vec3 colors[3] = vec3[](
    vec3(1.0, 0.0, 0.0),
    vec3(0.0, 1.0, 0.0),
    vec3(0.0, 0.0, 1.0)
);
```

あとは、これらの頂点ごとの色をフラグメントシェーダに渡すだけで、フレームバッファに補間された値を出力できるようになります。頂点シェーダに色の出力を追加し、`main` 関数に追加します。

```glsl
layout(location = 0) out vec3 fragColor;

void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
    fragColor = colors[gl_VertexIndex];
}
```

次に、フラグメントシェーダに対応する入力を追加する必要があります。

```glsl
layout(location = 0) in vec3 fragColor;

void main() {
    outColor = vec4(fragColor, 1.0);
}
```

入力変数は必ずしも同じ名前を使う必要はなく、`location` ディレクティブで指定されたインデックスを使ってリンクされます。`main` 関数がアルファ値とともに色を出力するように変更されました。上の画像のように、`fragColor` の値は、3つの頂点間のフラグメントに対して自動的に補間され、滑らかなグラデーションが得られます。

## シェーダーのコンパイル

プロジェクトのルートディレクトリに `shaders` というディレクトリを作り、その中に頂点シェーダを `shader.vert` というファイルに、フラグメントシェーダを `shader.frag` というファイルに格納します。GLSLのシェーダには公式の拡張子はありませんが、この2つは一般的に区別するために使われています。

`shader.vert`の内容は、次のようになっているはずです。

```glsl
#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(location = 0) out vec3 fragColor;

vec2 positions[3] = vec2[](
    vec2(0.0, -0.5),
    vec2(0.5, 0.5),
    vec2(-0.5, 0.5)
);

vec3 colors[3] = vec3[](
    vec3(1.0, 0.0, 0.0),
    vec3(0.0, 1.0, 0.0),
    vec3(0.0, 0.0, 1.0)
);

void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
    fragColor = colors[gl_VertexIndex];
}
```

そして、`shader.frag` の内容は次のようになっているはずです。

```glsl
#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(location = 0) in vec3 fragColor;

layout(location = 0) out vec4 outColor;

void main() {
    outColor = vec4(fragColor, 1.0);
}
```

これらを `glslc` を使って SPIR-V バイトコードにコンパイルします。

**Windows**

以下の内容の `compile.bat` ファイルを作成します。

```bash
C:/VulkanSDK/x.x.x.x/Bin32/glslc.exe shader.vert -o vert.spv
C:/VulkanSDK/x.x.x.x/Bin32/glslc.exe shader.frag -o frag.spv
pause
```

`glslc.exe`のパスをVulkan SDKをインストールしたパスに置き換えてください。ファイルをダブルクリックして実行します。

**Linux**

以下の内容の `compile.sh` ファイルを作成します。

```bash
/home/user/VulkanSDK/x.x.x.x/x86_64/bin/glslc shader.vert -o vert.spv
/home/user/VulkanSDK/x.x.x.x/x86_64/bin/glslc shader.frag -o frag.spv
```

`glslc` のパスを Vulkan SDK をインストールしたパスに置き換えてください。スクリプトを `chmod +x compile.sh` で実行可能にして実行します。

**プラットフォーム固有の指示終わり**。

これらの 2 つのコマンドは、コンパイラに GLSL ソースファイルを読み込んで、`-o` (output) フラグを使って SPIR-V バイトコードファイルを出力するように指示します。

シェーダに構文エラーがある場合、コンパイラは行番号と問題点を教えてくれます。例えば、セミコロンを消してコンパイルスクリプトを再度実行してみてください。また、コンパイラを引数なしで実行して、どのようなフラグをサポートしているかを確認してみてください。例えば、バイトコードを人間が読める形式で出力して、シェーダが実際には何をしているのか、またこの段階でどのような最適化が適用されたのかを確認することができます。

コマンドラインでシェーダをコンパイルするのは最も簡単な方法の一つで、このチュートリアルではこの方法を使用しますが、あなたのプログラムから直接シェーダをコンパイルすることも可能です。Vulkan SDKには[libshaderc](https://github.com/google/shaderc)が含まれています。プログラム内からGLSLコードをSPIR-Vにコンパイルするためのライブラリです。

## シェーダのロード

SPIR-V シェーダーを作成する方法ができたので、それをプログラムにロードして、グラフィックパイプラインにプラグインしてみましょう。まず、ファイルからバイナリデータをロードするための簡単なヘルパー関数を書きます。

```c++
#include <fstream>

...

static std::vector<char> readFile(const std::string& filename) {
    std::ifstream file(filename, std::ios::ate | std::ios::binary);

    if (!file.is_open()) {
        throw std::runtime_error("failed to open file!");
    }
}
```

関数 `readFile` は指定したファイルからすべてのバイトを読み込み、`std::vector` によって管理されるバイト配列で返します。まず、2つのフラグを指定してファイルを開きます。

* `ate`: ファイルの末尾から読み込みを開始する
* `binary`: バイナリファイルとして読み込む (テキストの変換を避ける)

ファイルの末尾から読み込みを開始する利点は、読み込み位置を使用してファイルのサイズを決定し、バッファを確保することができることです。

```c++
size_t fileSize = (size_t) file.tellg();
std::vector<char> buffer(fileSize);
```

その後、ファイルの先頭に戻って、一度にすべてのバイトを読み込むことができます。

```c++
file.seekg(0);
file.read(buffer.data(), fileSize);
```

最後にファイルを閉じてバイト列を返します。

```c++
file.close();

return buffer;
```

次に、`createGraphicsPipeline`からこの関数を呼び出して、2つのシェーダのバイトコードをロードします。

```c++
void createGraphicsPipeline() {
    auto vertShaderCode = readFile("shaders/vert.spv");
    auto fragShaderCode = readFile("shaders/frag.spv");
}
```

バッファのサイズを表示し、実際のファイルサイズとバイト数が一致しているかどうかを確認して、シェーダが正しくロードされていることを確認してください。このコードはバイナリコードであり、後でサイズを明確にするので、NULL 終端にする必要はないことに注意してください。

## シェーダモジュールの作成

コードをパイプラインに渡す前に、コードを `VkShaderModule` オブジェクトでラップしなければなりません。そのためのヘルパー関数 `createShaderModule` を作成しましょう。

```c++
VkShaderModule createShaderModule(const std::vector<char>& code) {

}
```

この関数はパラメータとしてバイトコードのバッファを受け取り、そこから `VkShaderModule` を作成します。

シェーダモジュールの作成は簡単で、バイトコードを含むバッファへのポインタとその長さを指定するだけです。この情報は `VkShaderModuleCreateInfo` 構造体で指定します。一つの注意点は、バイトコードのサイズはバイト単位で指定されていますが、バイトコードポインタは `char` ポインタではなく `uint32_t` ポインタになっていることです。そのため、以下のように `reinterpret_cast` でポインタをキャストする必要があります。このようなキャストを行う際には、データが `uint32_t` のアライメント要件を満たすことを確認する必要があります。幸いなことに、データは `std::vector` に格納されており、デフォルトのアロケータはデータが最悪の場合のアライメント要件を満たすことを既に保証しています。

```c++
VkShaderModuleCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
createInfo.codeSize = code.size();
createInfo.pCode = reinterpret_cast<const uint32_t*>(code.data());
```

`VkShaderModule` は `vkCreateShaderModule` を呼び出すことで作成することができます。

```c++
VkShaderModule shaderModule;
if (vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule) != VK_SUCCESS) {
    throw std::runtime_error("failed to create shader module!");
}
```

パラメータはこれまでのオブジェクト作成関数と同じです。論理デバイス、作成情報構造体へのポインタ、カスタムアロケータへのオプションのポインタ、出力変数のハンドルです。コードの入ったバッファは、シェーダモジュールを作成した直後に解放することができます。作成したシェーダモジュールをリターンすることを忘れないでください。

```c++
return shaderModule;
```

シェーダモジュールは、以前にファイルから読み込んだシェーダバイトコードとその中で定義されている関数の簡単なラッパーに過ぎません。SPIR-V のバイトコードをコンパイルして GPU で実行するためのマシンコードにリンクするのは、グラフィックスパイプラインが作成されるときです。つまり、パイプラインの作成が終了したらすぐにシェーダモジュールを破棄してもよいことになります。これが、シェーダモジュールをクラスメンバではなく `createGraphicsPipeline` 関数のローカル変数にする理由です。

```c++
void createGraphicsPipeline() {
    auto vertShaderCode = readFile("shaders/vert.spv");
    auto fragShaderCode = readFile("shaders/frag.spv");

    VkShaderModule vertShaderModule = createShaderModule(vertShaderCode);
    VkShaderModule fragShaderModule = createShaderModule(fragShaderCode);
```

`createGraphicsPipeline`関数の最後にクリーンアップとして `vkDestroyShaderModule` への呼び出しを 2 回追加します。この章の残りのコードはすべてこれらの行の前に挿入されます。

```c++
    ...
    vkDestroyShaderModule(device, fragShaderModule, nullptr);
    vkDestroyShaderModule(device, vertShaderModule, nullptr);
}
```

## シェーダステージの作成

実際にシェーダを使用するには、実際のパイプライン作成プロセスの一部として、`VkPipelineShaderStageCreateInfo` 構造体を使って特定のパイプラインステージにシェーダを割り当てる必要があります。

`createGraphicsPipeline` 関数内で、頂点シェーダの構造体のメンバを埋めていきます。

```c++
VkPipelineShaderStageCreateInfo vertShaderStageInfo{};
vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
```

まずは必須の `sType` メンバを埋め、次にどのパイプラインステージでシェーダが使用されるかをVulkanに伝えます。前の章で説明したプログラム可能なステージごとに列挙体の値があります。

```c++
vertShaderStageInfo.module = vertShaderModule;
vertShaderStageInfo.pName = "main";
```

次の2つのメンバは、コードを含むシェーダモジュールと、*entrypoint* と呼ばれる、呼び出す関数を指定します。つまり、複数のフラグメントシェーダを1つのシェーダモジュールにまとめて、エントリポイントにより呼び出す関数を変更し動作を変えることが可能です。しかし、今回は標準の `main` を使用します。

今回は使いませんが、説明する価値があるものとして、もう一つ（オプション）のメンバ `pSpecializationInfo` があります。これにより、シェーダ定数の値を指定することができます。1つのシェーダモジュールを使用していても、その中で使用される定数に異なる値を指定することで、パイプライン作成時にその動作を設定することができます。これは、レンダー時に変数を使用してシェーダを設定するよりも効率的です。なぜならば、コンパイラは、これらの値に依存する `if` 文を削除するなどの最適化を行うことができるからです。このような定数がない場合は、メンバを `nullptr` に設定することで、構造体の初期化が自動的に行われます。

フラグメントシェーダに合うように構造体を変更するのは簡単です。

```c++
VkPipelineShaderStageCreateInfo fragShaderStageInfo{};
fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
fragShaderStageInfo.module = fragShaderModule;
fragShaderStageInfo.pName = "main";
```

これら2つの構造体を含む配列を定義して終了します。この配列は、実際にパイプラインを作るステップで参照します。

```c++
VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo};
```

パイプラインのプログラマブルステージの説明は以上です。次の章では、機能が固定されている(fixed-functionな)ステージを見ていきます。

[C++ コード](/code/09_shader_modules.cpp) /
[頂点シェーダ](/code/09_shader_base.vert) /
[フラグメントシェーダ](/code/09_shader_base.frag)
