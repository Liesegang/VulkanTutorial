## セットアップ

パイプラインの作成を終える前に、レンダリング中に使用するフレームバッファのアタッチメントをVulkanに伝える必要があります。カラーバッファとデプスバッファの数、それぞれに使用するサンプルの数、レンダリング処理中にそれらの内容をどのように処理するかを指定する必要があります。これらの情報はすべて *レンダーパス* オブジェクトに格納されており、このオブジェクトを作るために新しい `createRenderPass` 関数を作成します。この関数は `initVulkan`関数内で、`createGraphicsPipeline` の前に呼び出してください。

```c++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
}

...

void createRenderPass() {

}
```

## アタッチメンドディスクリプション

ここでは、スワップチェインの画像の一つで表わされた単一のカラーバッファアタッチメントを使用しています。

```c++
void createRenderPass() {
    VkAttachmentDescription colorAttachment{};
    colorAttachment.format = swapChainImageFormat;
    colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
}
```

色のアタッチメントの `format` はスワップチェーンイメージのフォーマットと一致しなければなりません。マルチサンプリングはまだ何もしていないので、1サンプルにとどめておきます。

```c++
colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
```

`loadOp` と `storeOp` は、レンダリング前とレンダリング後にアタッチメントのデータをどうするかを決定します。

`loadOp`には以下の選択肢があります。

* `VK_ATTACHMENT_LOAD_OP_LOAD`: アタッチメントの既存の内容を保持
* `VK_ATTACHMENT_LOAD_OP_CLEAR`: 開始時に値を定数にクリア
* `VK_ATTACHMENT_LOAD_OP_DONT_CARE`: 既存の内容は未定義（既存の内容が何であれ気にしない）

ここでは、新しいフレームを描画する前にフレームバッファを黒くクリアするクリア操作を使います。

`storeOp`には2つの選択肢しかありません。

* `VK_ATTACHMENT_STORE_OP_STORE`: レンダリングされた内容はメモリに保存され、後で読み込めるようになります。
* `VK_ATTACHMENT_STORE_OP_DONT_CARE`: レンダリング操作の後、フレームバッファの内容は未定義になります。

レンダリングされた三角形が画面上に表示されているのが気になるので、ここでは前者にします。

```c++
colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
```

`loadOp` と `storeOp` はカラーとデプスデータに、`stencilLoadOp` と `stencilStoreOp` はステンシルデータに適用されます。私たちのアプリケーションはステンシルバッファに対して何もしないので、ロードとストアの結果は関係ありません。

```c++
colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
```

Vulkanのテクスチャとフレームバッファは、特定のピクセルフォーマットを持つ `VkImage` オブジェクトで表現されますが、メモリ内のピクセルのレイアウトは、その画像で何をしようとしているかによって変わります。

最も一般的なレイアウトは以下の通りです。

* `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`: カラーアタッチメントとして使用される画像
* `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`: スワップチェインで表示される画像
* `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`: メモリコピー操作のデスティネーションとして使用する画像

このトピックについてはテクスチャの章で詳しく説明しますが、ここで知っておくべき重要なことは、画像は、次に行う操作に適した特定のレイアウトに変換する必要があるということです。

`initialLayout` は、レンダリングパスが開始される前の画像のレイアウトを指定します。`finalLayout` は、レンダリングパスが終了したときに自動的に遷移するレイアウトを指定します。`inititialLayout` に `VK_IMAGE_LAYOUT_UNDEFINED` を指定すると、画像の前のレイアウトを気にしなくてもよいことになります。この特別な値の注意点は、画像の内容の保存が保証されていないことです。しかし、どうせクリアしてしまうので問題はありません。レンダリング後にスワップチェーンを使って画像を表示できるようにしたいので、`finalLayout`として `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` を使用します。

## サブパスとアタッチメントの参照

1 つのレンダーパスを複数のサブパスで構成することが出来ます。サブパスとは、前のパスのフレームバッファの内容に依存する後続のレンダリング操作のことで、例えば、次々に適用される一連のポストプロセッシングエフェクトなどがこれにあたります。これらのレンダリング操作を1つのレンダリングパスにグループ化すると、Vulkanは操作の順序を変更し、メモリ帯域幅を節約してパフォーマンスを向上させることができます。しかし、最初の三角形の例では、サブパスは1つにします。

すべてのサブパスは、前のセクションで構造体を使用して設定したアタッチメントを1つ以上参照します。これらの参照はそれ自体が `VkAttachmentReference` 構造体で、以下のようになります。

```c++
VkAttachmentReference colorAttachmentRef{};
colorAttachmentRef.attachment = 0;
colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
```

`attachment` パラメータは、どのアタッチメントを参照するかをアタッチメントディスクリプション配列のインデックスで指定します。この配列は単一の `VkAttachmentDescription` からなるので、そのインデックスは `0` です。`layout` は、この参照を使用するサブパスの間に、どのレイアウトのアタッチメントを使用したいかを指定します。Vulkanはサブパスの開始時にアタッチメントを自動的にこのレイアウトに変換します。今回はアタッチメントをカラーバッファとして使用します。その場合、その名の通り `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` レイアウトが最も良いパフォーマンスを発揮します。

サブパスは `VkSubpassDescription` 構造体を用いて記述されます。

Vulkanは将来的にはコンピュートサブパスもサポートする可能性があるので、これがグラフィックスサブパスであることを明示しなければなりません。

```c++
VkSubpassDescription subpass{};
subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
```

次に、色のアタッチメントへの参照を指定します。

```c++
subpass.colorAttachmentCount = 1;
subpass.pColorAttachments = &colorAttachmentRef;
```

この配列のアタッチメントのインデックスは、フラグメントシェーダから `layout(location = 0) out vec4 outColor` ディレクティブで直接参照できます。

サブパスで参照できるアタッチメントの他のタイプは以下の通りです。

* `pInputAttachments`: シェーダから読み込まれるアタッチメント
* `pResolveAttachments`: マルチサンプリングカラーのアタッチメントに使用されるアタッチメント
* `pDepthStencilAttachment`: デプスとステンシルデータのためのアタッチメント
* `pPreserveAttachments`: このサブパスでは使用されないが、サブパスのためにデータを保存しなければならないアタッチメント

## レンダーパス

アタッチメントとそれを参照する基本的なサブパスについて説明したので、レンダーパス自体を作成します。新しいクラスのメンバ変数として、 `VkRenderPass` オブジェクトを保持する変数と `pipelineLayout` オブジェクトを保持する変数を追加します。

```c++
VkRenderPass renderPass;
VkPipelineLayout pipelineLayout;
```

`VkRenderPassCreateInfo` 構造体にアタッチメントとサブパスの配列を設定することで、レンダーパスオブジェクトを作成できます。`VkAttachmentReference` オブジェクトは、この配列のインデックスを使用してアタッチメントを参照します。

```c++
VkRenderPassCreateInfo renderPassInfo{};
renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
renderPassInfo.attachmentCount = 1;
renderPassInfo.pAttachments = &colorAttachment;
renderPassInfo.subpassCount = 1;
renderPassInfo.pSubpasses = &subpass;

if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) {
    throw std::runtime_error("failed to create render pass!");
}
```

パイプラインレイアウトと同じように、レンダリングパスはプログラム全体で参照されるので、最後にクリーンアップします。

```c++
void cleanup() {
    vkDestroyPipelineLayout(device, pipelineLayout, nullptr);
    vkDestroyRenderPass(device, renderPass, nullptr);
    ...
}
```

ここまでそれはそれは大変な作業でしたが、次の章ではすべてがまとまり、ついにグラフィックパイプラインオブジェクトを作成が終わります！

[C++ コード](/code/11_render_passes.cpp) /
[頂点シェーダ](/code/09_shader_base.vert) /
[フラグメントシェーダ](/code/09_shader_base.frag)
