Vulkanには「デフォルトのフレームバッファ」という概念がないため、フレームバッファを画面上に描画する前に、レンダリングするバッファを指定するためのインフラストラクチャが必要です。このインフラストラクチャを*スワップチェーン*と呼び、Vulkan上で明示的に作成する必要があります。スワップチェーンは、基本的には画面に表示されるのを待っている画像のキューです。アプリケーションは、スワップチェーンから画像を取得してそこに描画し、それをキューに戻します。キューがどのように動作するか、またキューから画像を表示する条件は、スワップチェーンの設定によります。スワップチェーンの一般的な目的は、画像の表示を画面のリフレッシュレートに同期させることにあります。

## スワップチェーンのサポートのチェック

いろいろな理由で、すべてのグラフィックカードがスクリーンに直接画像を表示できるわけではありません。例えば、サーバーのためにデザインされておりディスプレー用のアウトプット端子が存在しないかもしれません。また、画像の表示はウィンドウシステムとウィンドウに関連するサーフェスに大きく依存しているため、実際にはVulkanコアの一部ではありません。画像の表示のサポートを問い合わせた後、`VK_KHR_swapchain` デバイスエクステンションを有効にする必要があります。

そのためにまず `isDeviceSuitable` 関数を拡張して、このエクステンションがサポートされているかどうかを確認します。`VkPhysicalDevice` でサポートされているエクステンションをリストアップする方法をステに見てきたため、それはとても簡単です。Vulkanのヘッダファイルには `VK_KHR_SWAPCHAIN_EXTENSION_NAME` という素敵なマクロがあり、これは `VK_KHR_swapchain` として定義されています。このマクロを使うことで、コンパイラが誤字を検出してくれる利点があります。

最初に、有効化するバリデーションレイヤーのリストと同様に、必要なデバイスエクステンションのリストを宣言します。

```c++
const std::vector<const char*> deviceExtensions = {
    VK_KHR_SWAPCHAIN_EXTENSION_NAME
};
```

次に、追加のチェックとして `isDeviceSuitable` から呼び出される新しい関数 `checkDeviceExtensionSupport` を作成します。

```c++
bool isDeviceSuitable(VkPhysicalDevice device) {
    QueueFamilyIndices indices = findQueueFamilies(device);

    bool extensionsSupported = checkDeviceExtensionSupport(device);

    return indices.isComplete() && extensionsSupported;
}

bool checkDeviceExtensionSupport(VkPhysicalDevice device) {
    return true;
}
```

関数の本体を変更して、エクステンションを列挙し、その中に必要なエクステンションがすべて含まれているかどうかをチェックします。

```c++
bool checkDeviceExtensionSupport(VkPhysicalDevice device) {
    uint32_t extensionCount;
    vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr);

    std::vector<VkExtensionProperties> availableExtensions(extensionCount);
    vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, availableExtensions.data());

    std::set<std::string> requiredExtensions(deviceExtensions.begin(), deviceExtensions.end());

    for (const auto& extension : availableExtensions) {
        requiredExtensions.erase(extension.extensionName);
    }

    return requiredExtensions.empty();
}
```

ここでは未確認の必須エクステンションを表すために文字列のセットを使うことにしました。これで、利用可能とわかったエクステンションをセットから簡単に取り除くことができます。もちろん、`checkValidationLayerSupport`のように入れ子になったループを使うこともできます。パフォーマンスの違いは関係ありません。コードを実行して、グラフィックスカードが実際にスワップチェーンを作成できるかどうかを確認してください。前の章で確認したように、プレゼンテーションキューが利用可能であることは、スワップチェーエクステンションがサポートされている必要があることを暗示していることに注意してください。しかし、物事を明確にすることはまだ良いことであり、エクステンションは明示的に有効にする必要があります。

## デバイスエクステンションの有効化

スワップチェーンを使用するには、まず `VK_KHR_swapchain` エクステンションを有効にする必要があります。エクステンションを有効にするには、論理デバイスの作成用の構造体を少し変更するだけです。

```c++
createInfo.enabledExtensionCount = static_cast<uint32_t>(deviceExtensions.size());
createInfo.ppEnabledExtensionNames = deviceExtensions.data();
```

既存の行 `createInfo.enabledExtensionCount = 0;` を置き換えてください。

## スワップチェーンサポートの詳細の問い合わせ

スワップチェーンが利用可能かどうかを確認するだけでは、それが私達が使うウィンドウサーフェースと互換性があるかわからないため、十分ではありません。スワップチェーンの作成には、インスタンスやデバイスの作成よりも多くの設定が必要になります。そのために、更に詳細な情報を要求する必要があります。

基本的には、3種類のプロパティをチェックする必要があります。

* 基本的なサーフェス機能（スワップチェーン内の画像の数の最小/最大、画像の幅と高さの最小/最大）
* サーフェスフォーマット（ピクセルフォーマット、カラースペース）
* 利用可能なプレゼンテーションモード

`findQueueFamilies`と同様に、一度問い合わせを行った後にこれらの詳細を渡すために構造体を使用します。前述の3種類のプロパティは、以下の構造体と構造体のリストの形で提供されます。

```c++
struct SwapChainSupportDetails {
    VkSurfaceCapabilitiesKHR capabilities;
    std::vector<VkSurfaceFormatKHR> formats;
    std::vector<VkPresentModeKHR> presentModes;
};
```

この構造体を作成する新しい関数 `querySwapChainSupport` を作成します。

```c++
SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device) {
    SwapChainSupportDetails details;

    return details;
}
```

このセクションでは、この情報を含む構造体を問い合わせる方法を説明します。これらの構造体の意味や、どのようなデータが含まれているかについては次のセクションで説明します。

まず、基本的なサーフェスの機能から説明します。これらのプロパティは問い合わせが簡単で、単一の `VkSurfaceCapabilitiesKHR` 構造体に返されます。

```c++
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &details.capabilities);
```

この関数は、指定された `VkPhysicalDevice` と `VkSurfaceKHR` ウィンドウの表面を考慮に入れて、サポートされる機能を決定します。すべてのサポート問い合わせ関数は、これら2つを最初のパラメータとして持ちます。なぜなら、その2つはスワップチェーンのコアコンポーネントであるからです。

次のステップは、サポートされているサーフェスの形式の問い合わせです。これは構造体のリストなので、いつものように、同じ関数を2ド呼び出し、まず数を問い合わせ、その後内容を問い合わせます。

```c++
uint32_t formatCount;
vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, nullptr);

if (formatCount != 0) {
    details.formats.resize(formatCount);
    vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, details.formats.data());
}
```

ベクトルが利用可能なすべてのフォーマットを保持するようにリサイズされていることを確認してください。サポートされているプレゼンテーションモードの問い合わせは 前述の`vkGetPhysicalDeviceSurfaceFormatsKHR` と全く同じように動作します。

```c++
uint32_t presentModeCount;
vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, nullptr);

if (presentModeCount != 0) {
    details.presentModes.resize(presentModeCount);
    vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, details.presentModes.data());
}
```

詳細はすべて構造体の中にありますので、`isDeviceSuitable` をもう一度拡張して、この関数を利用してスワップチェーンが適切にサポートされているかどうかを確認するようにしましょう。このチュートリアルでは、サポートされている画像フォーマットが少なくとも1つ、サポートされているプレゼンテーションモードが1つあれば、スワップチェーンのサポートは十分です。

```c++
bool swapChainAdequate = false;
if (extensionsSupported) {
    SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device);
    swapChainAdequate = !swapChainSupport.formats.empty() && !swapChainSupport.presentModes.empty();
}
```

重要なのは、エクステンションが利用可能であることを確認した後で、スワップチェーンのサポートを問い合わせることです。関数の最後の行は次のようなります。

```c++
return indices.isComplete() && extensionsSupported && swapChainAdequate;
```

## スワップチェーンの正しい設定の選択

もし `swapChainAdequate` の条件が満たされていれば、サポートは間違いなく十分ですが、より最適な設定のための様々なモードがまだ存在するかもしれません。ここで、最適なスワップチェーンの設定を見つけるための、関数をいくつか作りましょう。決定する設定は3種類あります。

* 表面フォーマット（色の濃さ）
* プレゼンテーションモード（画像を画面に「スワップ」する条件）
* スワップエクステント（スワップチェーン内の画像の解像度）

それぞれの設定について、理想的な値があればそれを使用し、それ以外の場合は次に最適なものを見つけるためのロジックを作成します。

### サーフェスの形式

この設定のための関数は以下のようなコードで始まります。後ほど `SwapChainSupportDetails` 構造体の `formats` メンバを引数に渡します。

```c++
VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) {

}
```

それぞれの `VkSurfaceFormatKHR` エントリには `format` と `colorSpace` メンバが含まれています。`format` メンバはカラーチャンネルとタイプを指定します。例えば、`VK_FORMAT_B8G8R8A8_SRGB`は、B, G, R, アルファの順に各チャンネルを8ビットの符号なし整数で格納し、1ピクセルあたり合計32ビットであることを意味します。`colorSpace` メンバは、`VK_COLOR_SPACE_SRGB_NONLINEAR_KHR` フラグにより、SRGB色空間がサポートされているかどうかを示します。このフラグは古いバージョンの仕様では `VK_COLORSPACE_SRGB_NONLINEAR_KHR` と呼ばれていました。

色空間にはSRGBが利用できる場合にはSRGBを使用します。なぜならそれが、 [より正確に色が知覚できる](http://stackoverflow.com/questions/12524623/)からです。また、後に使用するテクスチャのような画像の標準的な色空間でもあります。そのため、SRGBカラーフォーマットの中から選ぶ必要がありますが、その中で最も一般的なものは `VK_FORMAT_B8G8R8A8_SRGB` です。

リストを見て、良い組み合わせが利用できるかどうかを確認してみましょう。

```c++
for (const auto& availableFormat : availableFormats) {
    if (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
        return availableFormat;
    }
}
```

もしそれが失敗した場合は、それらがどれだけ「良い」かに基づいて利用可能なフォーマットのランキング付けを行うことが出来ます。しかし、ほとんどの場合、最初に指定されたフォーマットで良いでしょう。

```c++
VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) {
    for (const auto& availableFormat : availableFormats) {
        if (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
            return availableFormat;
        }
    }

    return availableFormats[0];
}
```

### プレゼンテーションモード

プレゼンテーションモードは、画像を画面に表示するための実際の条件であり、スワップチェーンにとって最も重要な設定す。Vulkanには4つのモードがあります。

* `VK_PRESENT_MODE_IMMEDIATE_KHR`: アプリケーションから送信された画像がすぐに画面に転送されるため、[ティアリング](ja.wikipedia.org/wiki/ティアリング)が発生する可能性があります
* `VK_PRESENT_MODE_FIFO_KHR`: ディスプレイがリフレッシュされたときに、ディスプレイはキューの先頭から画像を取得し、プログラムがキューの後ろにレンダリングされた画像を挿入します。キューが一杯になった場合は、プログラムは待たなければなりません。これは、最近のゲームで見られる垂直同期に最も似ています。ディスプレイがリフレッシュされる瞬間を「垂直ブランク」と呼びます
* `VK_PRESENT_MODE_FIFO_RELAXED_KHR`. このモードは、前のモードと似ていますが、アプリケーションが遅延していて、最後の垂直ブランク時にキューが空だった場合に異なります。次の垂直ブランクを待つのではなく、最終的に画像が到着したらすぐに転送されます。このため、目に見えるティアリングが発生する可能性があります。
* `VK_PRESENT_MODE_MAILBOX_KHR`. これは2番目のモードの別のバリエーションです。キューが一杯になったときにアプリケーションをブロックするのではなく、すでにキューに入っている画像を新しい画像に単純に置き換えます。このモードはトリプルバッファリングを実装するために使用でき、ダブルバッファリングを使用する標準的な垂直同期よりも大幅に少ないレイテンシでティアリングを回避することができます。

`VK_PRESENT_MODE_FIFO_KHR` モードだけが保証されているので、利用可能な最良のモードを探す関数を再び書かなければなりません。

```c++
VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR>& availablePresentModes) {
    return VK_PRESENT_MODE_FIFO_KHR;
}
```

個人的には、トリプルバッファリングは非常に良いトレードオフだと思います。縦方向の空白の直前まで可能な限り最新の画像をレンダリングすることで、かなり低いレイテンシを維持しながらティアリングを回避することができます。ということで、それがあるかリストを見てみましょう。

```c++
VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR>& availablePresentModes) {
    for (const auto& availablePresentMode : availablePresentModes) {
        if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) {
            return availablePresentMode;
        }
    }

    return VK_PRESENT_MODE_FIFO_KHR;
}
```

### スワップエクステント

これでメジャーなプロパティは残すところ一つだけとなりました。そのための関数を追加しましょう。

```c++
VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) {

}
```

スワップエクステントはスワップチェーン画像の解像度であり、ほとんどの場合、_in pixel_に描画しているウィンドウの解像度と正確に等しくなります (これについては後ほど詳しく説明します)。可能な解像度の範囲は `VkSurfaceCapabilitiesKHR` 構造体で定義されています。Vulkanは、ウィンドウの解像度に合わせるて`currentExtent`メンバに幅と高さを設定するよう指示しています。しかし、いくつかのウィンドウマネージャはここでの違いを許容しており、その場合は `currentExtent` の幅と高さを特別な値、すなわち `uint32_t` の最大値に設定します。この場合、`minImageExtent` と `maxImageExtent` の範囲内でウィンドウに最もマッチする解像度を選びます。注意しなければならないのは、解像度を正しい単位で指定しなければならないということです。

GLFWはサイズを表す際にピクセルと[スクリーン座標](https://www.glfw.org/docs/latest/intro_guide.html#coordinate_systems)の2つの単位を使います。例えば、先ほどウィンドウを作成する際に指定した解像度 `{WIDTH, HEIGHT}` は、スクリーン座標で表されます。しかし、Vulkanはピクセルを使うため、スワップチェーンの範囲もピクセルで指定する必要があります。残念ながら、高DPIディスプレイ（AppleのRetinaディスプレイなど）を使用している場合、画面座標はピクセルに対応していません。ピクセル密度が高いため、ピクセル単位のウィンドウの解像度は、スクリーン座標の解像度よりも大きくなります。そのため、Vulkanがスワップ範囲を修正してくれない場合、元の `{WIDTH, HEIGHT}` を使うことはできません。その代わりに、最小および最大の画像エクステントに合うか確認する前に、`glfwGetFramebufferSize`を使ってウィンドウの解像度をピクセル単位で取得しなければなりません。

```c++
#include <cstdint> // Necessary for UINT32_MAX

...

VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) {
    if (capabilities.currentExtent.width != UINT32_MAX) {
        return capabilities.currentExtent;
    } else {
        int width, height;
        glfwGetFramebufferSize(window, &width, &height);

        VkExtent2D actualExtent = {
            static_cast<uint32_t>(width),
            static_cast<uint32_t>(height)
        };

        actualExtent.width = std::max(capabilities.minImageExtent.width, std::min(capabilities.maxImageExtent.width, actualExtent.width));
        actualExtent.height = std::max(capabilities.minImageExtent.height, std::min(capabilities.maxImageExtent.height, actualExtent.height));

        return actualExtent;
    }
}
```

ここでは、`max` と `min` 関数を用いて、`WIDTH` と `HEIGHT` の値を、実装でサポートされている最小エクステントと最大エクステントの間でクランプします。これらを使用するには、`<algorithm>` ヘッダを必ずインクルードしてください。

## スワップチェーンの作成

これで、実行時の設定の選択に用いるヘルパー関数がすべて揃ったので、いよいよ機能するスワップチェーンを作成するために必要な情報がすべて揃ったことになります。

`createSwapChain` 関数を作成し、論理デバイスの作成後に `initVulkan` から呼び出すようにしてください。`createSwapChain`では、まずこれらの関数の呼び出しの結果を取得することから始まります。

```c++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
}

void createSwapChain() {
    SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice);

    VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats);
    VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes);
    VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities);
}
```

これらのプロパティとは別に、スワップチェーンに何枚のイメージを持たせるかを決める必要があります。実装では、機能するために必要な最小数を指定しています。

```c++
uint32_t imageCount = swapChainSupport.capabilities.minImageCount;
```

しかし、この最小数にすると、次のイメージを取得してレンダリングするために、ドライバの内部処理が完了するのを待たなければならないことがあります。そのため、最小より1つ多い数のの画像を指定することをお勧めします。

```c++
uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1;
```

また、これを行う際には、画像の最大数を超えないようにしなければなりません。`0`は、最大値がないことを表す特別な値です。

```c++
if (swapChainSupport.capabilities.maxImageCount > 0 && imageCount > swapChainSupport.capabilities.maxImageCount) {
    imageCount = swapChainSupport.capabilities.maxImageCount;
}
```

Vulkanオブジェクトの伝統として、スワップチェーンオブジェクトを作成するには、大きな構造体を埋める必要があります。よく見慣れたところから始めましょう。

```c++
VkSwapchainCreateInfoKHR createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
createInfo.surface = surface;
```

スワップチェーンをどのサーフェスに結びつけるかを指定し、スワップチェーンイメージの詳細を指定します。

`imageArrayLayers` は各画像を構成するレイヤーの数を指定します。ステレオスコープな3Dアプリケーションを開発している場合を除き、これは常に `1` です。`imageUsage` ビットフィールドは、スワップチェーン内の画像をどのような操作に使うかを指定します。このチュートリアルでは、画像に直接レンダリングすることを想定していますが、これはカラーアタッチメントとして使用することを意味します。また、ポストプロセッシングのような操作を行うために、最初に画像を別の画像にレンダリングすることも可能です。その場合は、`VK_IMAGE_USAGE_TRANSFER_DST_BIT`のような値を代わりに使用して、メモリ操作を利用してレンダリングした画像をスワップチェーン画像に転送します。

```c++
createInfo.minImageCount = imageCount;
createInfo.imageFormat = surfaceFormat.format;
createInfo.imageColorSpace = surfaceFormat.colorSpace;
createInfo.imageExtent = extent;
createInfo.imageArrayLayers = 1;
createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
```

次に、複数のキューファミリーにまたがって使用されるスワップチェーン画像をどのように扱うかを指定する必要があります。このアプリケーションでは、グラフィックスキューのファミリがプレゼンテーションキューとは異なる場合です。私たちは、グラフィックスキューからスワップチェーン内の画像を描画し、 プレゼンテーションキューに送信することになります。複数のキューからアクセスされる画像を扱うには、以下の2つのモードがあります。

* `VK_SHARING_MODE_EXCLUSIVE`: 画像は一度に一つのキューファミリーが所有しており、別のキューファミリーで使用する前に所有権を明示的に移転しなければなりません。このオプションは最高のパフォーマンスを提供します。
* `VK_SHARING_MODE_CONCURRENT`: 画像は、明示的に所有権を移転することなしに、またがって利用することができます。

キューファミリーが異なる場合は、このチュートリアルでは CONCURRENT モードを使用して、 所有権の転送を行う必要を避けることにします。 CONCURRENT モードでは、`queueFamilyIndexCount` および `pQueueFamilyIndices` パラメータを用いて、どのキューファミリー間で所有権を共有するかを事前に指定しておく必要があります。多くのハードウェアでそうなのですが、グラフィックスキューファミリとプレゼンテーションキューファミリが同じであれば、 エクスクルーシブモードにすべきです。なぜなら、 CONCURRENT モードは、 `queueFamilyIndexCount` に少なくとも2つの異なるキューファミリーを指定する必要があるからです。

```c++
QueueFamilyIndices indices = findQueueFamilies(physicalDevice);
uint32_t queueFamilyIndices[] = {indices.graphicsFamily.value(), indices.presentFamily.value()};

if (indices.graphicsFamily != indices.presentFamily) {
    createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
    createInfo.queueFamilyIndexCount = 2;
    createInfo.pQueueFamilyIndices = queueFamilyIndices;
} else {
    createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
    createInfo.queueFamilyIndexCount = 0; // Optional
    createInfo.pQueueFamilyIndices = nullptr; // Optional
}
```

特定の変換がサポートされていれば (`capabilities` の `supportedTransforms`)、スワップチェーン内の画像に適用する変換を指定することができます (例えば、時計回りに 90 度回転したり、水平反転したり)。何も変換しないことを指定するには、currentTransform を指定します。

```c++
createInfo.preTransform = swapChainSupport.capabilities.currentTransform;
```

`compositeAlpha` フィールドは、ウィンドウシステム内の他のウィンドウとのブレンドにアルファチャンネルを使用するかどうかを指定します。ほとんどの場合、アルファチャンネルを無視したい場合が多いので、 `VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR` となります。

```c++
createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
```

`presentMode` メンバは名前のとおりです。`clipped` メンバが `VK_TRUE` に設定されている場合は、ピクセルの前に別のウィンドウがあるなどの理由で見えなくなっているピクセルの色を気にしないことを意味します。これらのピクセルを読み込んで何かをする必要がない限り、クリッピングを有効にすることで最高のパフォーマンスを得ることができます。

```c++
createInfo.presentMode = presentMode;
createInfo.clipped = VK_TRUE;
```

最後は `oldSwapChain` フィールドです。Vulkanでは、例えばウィンドウがリサイズされたりなどして、アプリケーションの実行中にスワップチェーンが無効になったり、最適化されていなくなる可能性があります。その場合、スワップチェーンをゼロから作り直す必要があります。その際には、このフィールドに古いスワップチェーンへの参照を指定しなければなりません。これは複雑なトピックで、[今後の章](!ja/三角形を描く/スワップチェーンの作成)で詳しく説明します。今のところ、スワップ・チェーンは1つしか作成しないことを想定しています。

```c++
createInfo.oldSwapchain = VK_NULL_HANDLE;
```

クラスメンバーを追加して `VkSwapchainKHR` オブジェクトを格納します。

```c++
VkSwapchainKHR swapChain;
```

スワップチェーンの作成は `vkCreateSwapchainKHR` を呼び出すだけで簡単にできます。パラメータは論理デバイス、スワップチェーン作成情報、オプションのカスタムアロケータ、ハンドルを格納する変数へのポインタです。

```c++
if (vkCreateSwapchainKHR(device, &createInfo, nullptr, &swapChain) != VK_SUCCESS) {
    throw std::runtime_error("failed to create swap chain!");
}
```

もちろん、デバイスのクリーンアップの前に `vkDestroySwapchainKHR` を使ってクリーンアップする必要があります。

```c++
void cleanup() {
    vkDestroySwapchainKHR(device, swapChain, nullptr);
    ...
}
```

アプリケーションを実行してスワップチェーンが正常に作成されたことを確認してください。この時点で `vkCreateSwapchainKHR` でアクセス違反エラーが発生したり、`Failed to find 'vkGetInstanceProcAddress' in layer SteamOverlayVulkanLayer.dll` のようなメッセージが表示された場合は、[FAQ エントリ](!ja/FAQ)のSteam オーバーレイレイヤーに関する項目を参照してください。

バリデーションレイヤーを有効にした状態で `createInfo.imageExtent = extent;` の行を削除してみてください。バリデーションレイヤーがすぐに間違いを検出し、有用なメッセージが表示されることがわかります。

![](/images/swap_chain_validation_layer.png)

## スワップチェーン画像の取得

これでスワップチェーンが作成されたので、あとは `VkImage` のハンドルを取得するだけです。後の章では、レンダリング操作の際にこれらを参照します。ハンドルを格納するクラスメンバを追加しましょう。

```c++
std::vector<VkImage> swapChainImages;
```

イメージはスワップチェーンの実装によって作成されたものであるので、スワップチェーンが破棄されると自動的にクリーンアップされます。よって、クリーンアップコードを追加する必要はありません。

ハンドルを取得するコードを `createSwapChain` 関数の最後、`vkCreateSwapchainKHR` コールの直後に追加しています。これらを取得するのは、先ほどのVulkanからオブジェクトの配列を取得するのと非常に似ています。スワップチェーンの画像の最小数を指定しただけなので、実装ではそれ以上の数のスワップチェーンを作成することが許されていることを覚えておいてください。そのため、まず `vkGetSwapchainImagesKHR` で最終的な画像の数を問い合わせてから、コンテナのサイズを変更し、最後にもう一度呼び出してハンドルを取得します。

```c++
vkGetSwapchainImagesKHR(device, swapChain, &imageCount, nullptr);
swapChainImages.resize(imageCount);
vkGetSwapchainImagesKHR(device, swapChain, &imageCount, swapChainImages.data());
```

最後に、スワップチェーン画像のフォーマットと範囲をメンバー変数に設定します。これらは今後の章で必要になるでしょう。

```c++
VkSwapchainKHR swapChain;
std::vector<VkImage> swapChainImages;
VkFormat swapChainImageFormat;
VkExtent2D swapChainExtent;

...

swapChainImageFormat = surfaceFormat.format;
swapChainExtent = extent;
```

これで、描画して、ウィンドウに表示することができる画像のセットができました。次の章では、レンダリングターゲットとして画像をセットアップする方法を説明し、実際のグラフィックパイプラインと描画コマンドを見ていきます。

[C++ コード](/code/06_swap_chain_creation.cpp)
