Vulkanはプラットフォームに依存しないAPIなので、それ自体ではウィンドウシステムと直接インタフェースすることはできません。結果を画面に表示するためにVulkanとウィンドウシステム間の接続を確立するには、WSI(Window System Integration)エクステンションを使う必要があります。この章ではその一つである`VK_KHR_surface` エクステンションについて見ていきます。これはレンダリングされた画像を表示するための抽象的なタイプのサーフェスを表す `VkSurfaceKHR` オブジェクトを提供しています。このプログラムのサーフェスはGLFWで既に開いているウィンドウに表示されています。

`VK_KHR_surface` エクステンションはインスタンスレベルのエクステンションで、`glfwGetRequiredInstanceExtensions` が返すリストに含まれているので、実際にはすでに有効化されています。このリストには他にもいくつかの WSI エクステンションが含まれており、続くいくつかの章で使うことになります。

ウィンドウサーフェスは、物理デバイスの選択に影響を与える可能性があるため、インスタンス作成の直後に作成する必要があります。説明を先延ばしにした理由は、ウィンドウサーフェスはレンダーターゲットとプレゼンテーションというより大きなトピックの一部であり、基本的なセットアップと同時にウィンドウサーフェスの説明をすると話が煩雑になるからです。また、ウィンドウサーフェスは、オフスクリーンレンダリングが必要な場合には、Vulkanでは完全にオプショナルなコンポーネントであることにも注意してください。Vulkanでは、不可視ウィンドウの作成（OpenGLでは必要）のようなハックをしなくても、これを行うことができます。

## ウィンドウサーフェスの作成

まず、デバッグコールバックのすぐ下に `surface` クラスのメンバを追加します。

```c++
VkSurfaceKHR surface;
```

`VkSurfaceKHR` オブジェクトとその使用法はプラットフォームに依存しませんが、その作成はウィンドウシステムの詳細に依存するためプラットフォームに非依存ではありません。例えば、Windowsでは `HWND` と `HMODULE` のハンドルが必要です。そのため、プラットフォーム固有のエクステンションが追加されており、Windowsでは `VK_KHR_win32_surface` と呼ばれ、`glfwGetRequiredInstanceExtensions` から自動的にリストに追加されます。

このプラットフォーム固有のエクステンションを使ってWindows上でサーフェスを作成する方法を紹介しますが、このチュートリアルでは実際には使いません。GLFWのようなライブラリを使っているのにも関わらず、プラットフォーム固有のコードを書いては意味がありません。GLFWには実際には `glfwCreateWindowSurface` があり、プラットフォーム間のの違いを処理してくれます。それでも、GLFWを使う前に、裏で何をしているのかを知るのは良いことです。

ウィンドウサーフェスはVulkanオブジェクトなので、`VkWin32SurfaceCreateInfoKHR` 構造体を作らなければなりません。この構造体には2つの重要なパラメータがあります。`hwnd` と `hinstance` です。これらはウィンドウとプロセスのハンドルです。

```c++
VkWin32SurfaceCreateInfoKHR createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
createInfo.hwnd = glfwGetWin32Window(window);
createInfo.hinstance = GetModuleHandle(nullptr);
```

GLFWウィンドウオブジェクトから生の `HWND` を取得するには、`glfwGetWin32Window` 関数を用います。`GetModuleHandle` 関数は現在のプロセスの `HINSTANCE` ハンドルを返します。

その後、`vkCreateWin32SurfaceKHR`関数によってサーフェスを作成します。この関数はパラメータとして、インスタンス・サーフェス作成の詳細・カスタムアロケータ・サーフェスハンドルを格納する変数を取ります。技術的にはこれは WSI 拡張関数ではありますが、一般的に使用されているため標準の Vulkan ローダに含まれており、他の拡張関数とは異なり、明示的にロードする必要はありません。

```c++
if (vkCreateWin32SurfaceKHR(instance, &createInfo, nullptr, &surface) != VK_SUCCESS) {
    throw std::runtime_error("failed to create window surface!");
}
```

Linuxのような他のプラットフォームでも手順は同様です。`vkCreateXcbSurfaceKHR` は、作成するための詳細情報として、X11からXCB接続とウィンドウを受け取ります。

`glfwCreateWindowSurface` 関数は、プラットフォームごとに実装が異なりますが、この操作を正確に実行します。これをプログラムに統合してみましょう。インスタンス作成と `setupDebugMessenger` の直後に `initVulkan` から呼び出される関数 `createSurface` を追加します。

```c++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
}

void createSurface() {

}
```

GLFWの呼び出しは構造体の代わりに単純なパラメータを取るため、関数の実装が非常に簡単です。

```c++
void createSurface() {
    if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) {
        throw std::runtime_error("failed to create window surface!");
    }
}
```

パラメータは `VkInstance`・GLFWウィンドウポインタ・カスタムアロケータ・変数 `VkSurfaceKHR`へのポインタです。これは単に関連するプラットフォーム呼び出しからの `VkResult` を通過させるだけです。GLFWはサーフェスを破棄するための特別な関数を提供していませんが、それはオリジナルのAPIを通して簡単に行うことができます。

```c++
void cleanup() {
        ...
        vkDestroySurfaceKHR(instance, surface, nullptr);
        vkDestroyInstance(instance, nullptr);
        ...
    }
```

インスタンスの破棄より前にサーフェスが破棄されるようにしてください。

## プレゼンテーションのサポートのためのクエリ

Vulkanの実装はウィンドウシステムの統合をサポートしているかもしれませんが、システム内のすべてのデバイスがそれをサポートしているわけではありません。したがって、私たちは `isDeviceSuitable` を拡張して、デバイスがサーフェスに画像をプレゼンテーションする機能があることを保証する必要があります。プレゼンテーションはキュー固有の機能なので、実際にやることは、我々が作成したサーフェスへのプレゼンテーションをサポートするキューファミリーを見つけることです。

描画コマンドをサポートしているキューファミリーと、プレゼンテーションをサポートしているキューファミリーが同じでない可能性があります。そのため、`QueueFamilyIndices` 構造体を変更して、別のプレゼンテーション用キューが存在する可能性を考慮しなければなりません。

```c++
struct QueueFamilyIndices {
    std::optional<uint32_t> graphicsFamily;
    std::optional<uint32_t> presentFamily;

    bool isComplete() {
        return graphicsFamily.has_value() && presentFamily.has_value();
    }
};
```

次に、`findQueueFamilies` 関数を修正して、ウィンドウサーフェスへのプレゼンテーション機能を持つキューファミリーを探します。これをチェックする関数は `vkGetPhysicalDeviceSurfaceSupportKHR` で、物理デバイス、キューファミリーインデックス、サーフェスをパラメータとして受け取ります。これを `VK_QUEUE_GRAPHICS_BIT` と同じループ内で呼び出しを追加します。

```c++
VkBool32 presentSupport = false;
vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentSupport);
```

そして、単純に値をチェックして、プレゼンテーションファミリーのキューインデックスを格納します。

```c++
if (presentSupport) {
    indices.presentFamily = i;
}
```

これらが結局は同じキューファミリーである可能性が非常に高いことに注意してください。 しかし、プログラム全体を通して、統一されたアプローチのために、あたかもそれらが別々のキューであるかのようにそれらを扱います。それにもかかわらず、パフォーマンスを向上させるために、同じキューで描画とプレゼンテーションをサポートする物理デバイスを明示的に好むようなロジックを追加することができます。

## プレゼンテーションキューの作成

最後に、プレゼンテーションキューを作成して `VkQueue` ハンドルを取得するために論理デバイス作成の手順を修正することです。まず、ハンドルのメンバ変数を追加します。

```c++
VkQueue presentQueue;
```

次に、両方のファミリからキューを作成するために、複数の `VkDeviceQueueCreateInfo` 構造体を持つ必要があります。これを行うエレガントな方法は、要求されたキューに必要なすべてのキューファミリーを重複なく含むsetを作成することです。

```c++
#include <set>

...

QueueFamilyIndices indices = findQueueFamilies(physicalDevice);

std::vector<VkDeviceQueueCreateInfo> queueCreateInfos;
std::set<uint32_t> uniqueQueueFamilies = {indices.graphicsFamily.value(), indices.presentFamily.value()};

float queuePriority = 1.0f;
for (uint32_t queueFamily : uniqueQueueFamilies) {
    VkDeviceQueueCreateInfo queueCreateInfo{};
    queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    queueCreateInfo.queueFamilyIndex = queueFamily;
    queueCreateInfo.queueCount = 1;
    queueCreateInfo.pQueuePriorities = &queuePriority;
    queueCreateInfos.push_back(queueCreateInfo);
}
```

そして、そのベクトルを指すように `VkDeviceCreateInfo` を修正します。

```c++
createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size());
createInfo.pQueueCreateInfos = queueCreateInfos.data();
```

キューファミリーが同じであれば、インデックスを一度だけ渡せば十分です。最後に、キューハンドルを取得するための関数呼び出しを追加します。

```c++
vkGetDeviceQueue(device, indices.presentFamily.value(), 0, &presentQueue);
```

キューファミリーが同じであれば、2つのハンドルはほとんどの場合同じ値を持つことになります。

[次の章](!ja/三角形を描く/プレゼンテーション/スワップチェーン)では、スワップチェーンと、それがどのようにしてサーフェスに画像を表示するかを見ていきます。

[C++ コード](/code/05_window_surface.cpp)
