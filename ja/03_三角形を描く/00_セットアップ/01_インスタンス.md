## インスタンスの作成

最初に行う必要があるのは、*インスタンス* を作成してVulkanライブラリを初期化することです。インスタンスはアプリケーションとVulkanライブラリを繋ぐもので、インスタンスの作成にはアプリケーションの詳細をドライバに伝える必要があります。

まず、 `createInstance` 関数を追加し、 `initVulkan` 関数の中でそれを呼び出します。

```c++
void initVulkan() {
    createInstance();
}
```

さらに、インスタンスのハンドルを保持するデータメンバを追加します。

```c++
private:
VkInstance instance;
```

インスタンスを作成するためには、まず構造体でアプリケーションに関する情報を指定する必要があります。このデータは技術的にはオプションですが、特定のアプリケーションを最適化するためにドライバに有用な情報を提供するかもしれません(例えば、特定の特殊な動作を持つ有名なグラフィックス・エンジンを使用しているため)。この構造体は `VkApplicationInfo` と呼ばれます。

```c++
void createInstance() {
    VkApplicationInfo appInfo{};
    appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    appInfo.pApplicationName = "Hello Triangle";
    appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
    appInfo.pEngineName = "No Engine";
    appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);
    appInfo.apiVersion = VK_API_VERSION_1_0;
}
```

前述したように、Vulkan の多くの構造体は `sType` メンバで明示的にタイプを指定する必要があります。多くの構造体のは将来的に拡張情報を指すことができる `pNext` メンバを持ちますが、`VkApplicationInfo`もまたその一つです。ここでは値の初期化を使って `nullptr` のままにしています。

Vulkanでは多くの情報が関数のパラメータではなく構造体を通して渡されます。インスタンスを作成するための十分な情報を提供するために、もう一つの構造体を埋める必要があります。この次の構造体はオプションではありません。Vulkanドライバに使用するグローバルエクステンションとバリデーションレイヤーを指定します。ここでいうグローバルとは、特定のデバイスではなくプログラム全体に適用されることを意味します。グローバルの意味は、次の数章で明らかになるでしょう。

```c++
VkInstanceCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
createInfo.pApplicationInfo = &appInfo;
```

最初の2つのパラメータは簡単です。次の2つのレイヤーは、希望するグローバルエクステンションを指定します。概要の章で述べたように、Vulkanはプラットフォームに依存しないAPIであり、ウィンドウシステムとのインターフェースにはエクステンションが必要です。GLFWには、構造体に渡すためのエクステンションを返す便利な組み込み関数があります。

```c++
uint32_t glfwExtensionCount = 0;
const char** glfwExtensions;

glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

createInfo.enabledExtensionCount = glfwExtensionCount;
createInfo.ppEnabledExtensionNames = glfwExtensions;
```

構造体の最後の2つのメンバーで、有効にするグローバルバリデーションレイヤーを決めます。これらについては次の章で詳しく説明しますので、今は空欄のままにしておきましょう。

```c++
createInfo.enabledLayerCount = 0;
```

これでVulkanがインスタンスを作成するために必要なすべてのものが指定できたので、最後に `vkCreateInstance` をコールすることができます。

```c++
VkResult result = vkCreateInstance(&createInfo, nullptr, &instance);
```

今見てきたように、Vulkanのオブジェクト生成関数のパラメータの一般的なパターンは以下の通りです。

* 作成情報を含む構造体へのポインタ
* カスタムアロケータコールバックへのポインタ（このチュートリアルでは常に `nullptr`）
* 新しいオブジェクトのハンドルを格納する変数へのポインタ

すべてがうまくいった場合、インスタンスのハンドルは `VkInstance` クラスメンバに格納されます。ほとんどすべてのVulkan関数は `VkResult` 型の値を返します。その値は `VK_SUCCESS` かエラーコードです。インスタンスが正常に作成されたかどうかを確認するために、値を変数に保存する必要はありません。代わりに成功値との比較をしましょう。

```c++
if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) {
    throw std::runtime_error("failed to create instance!");
}
```

プログラムを実行して、インスタンスが正常に作成されたことを確認してください。

## エクステンションのサポートの確認

`vkCreateInstance` のドキュメントを見ると、エラーコードの一つに `VK_ERROR_EXTENSION_NOT_PRESENT` があることがわかります。必要なエクステンションを指定して、このエラーコードが返ってきたら、ただ終了させればいいのです。しかし、ウィンドウシステムインターフェイスのような必須のエクステンションの場合はそれでようですが、オプションの機能をチェックしたい場合はどうしたらいいでしょうか。


インスタンスを作成する前にサポートされているエクステンションのリストを取得するには、`vkEnumerateInstanceExtensionProperties` 関数を用います。これはエクステンションの数を格納する変数へのポインタとエクステンションの詳細を格納するための `VkExtensionProperties` の配列を受け取ります。また、オプションの最初のパラメータを指定することで特定のバリデーションレイヤーでエクステンションをフィルタリングすることができます。今回はフィルタリングは使用しません。

エクステンションの詳細を格納する配列を確保するには、まずエクステンションの数を知る必要があります。最後のパラメータを空のままにしておくと、エクステンションの数だけを要求することができます。

```c++
uint32_t extensionCount = 0;
vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr);
```

次に、エクステンションの詳細を保持する配列を確保します (`include <vector>`)。

```c++
std::vector<VkExtensionProperties> extensions(extensionCount);
```

最後に、エクステンションの詳細を問い合わせることができます。

```c++
vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, extensions.data());
```

それぞれの `VkExtensionProperties` 構造体にはエクステンションの名前とバージョンが含まれています。単純なforループで一覧を見ることが出来ます。(`\t`はインデントのためのタブです。)

```c++
std::cout << "available extensions:\n";

for (const auto& extension : extensions) {
    std::cout << '\t' << extension.extensionName << '\n';
}
```

Vulkan サポートについての詳細な情報を得たければ、このコードを `createInstance` 関数に追加しましょう。課題として、`glfwGetRequiredInstanceExtensions` が返すエクステンションがすべてサポートされているエクステンションリストに含まれているかどうかをチェックする関数を作ってみてください。

## クリーンアップ

`VkInstance` はプログラムが終了する直前にのみ破棄されるべきです。`cleanup` で `vkDestroyInstance` 関数を使って破棄しましょう。

```c++
void cleanup() {
    vkDestroyInstance(instance, nullptr);

    glfwDestroyWindow(window);

    glfwTerminate();
}
```

`vkDestroyInstance` 関数のパラメータは簡単です。前章で述べたように、Vulkanのアロケーションとデアロケーション関数にはオプションのアロケータコールバックがありますが、これは `nullptr` を渡すことで無視することができます。次の章で作成する他のすべてのVulkanリソースは、インスタンスが破棄される前にクリーンアップしておく必要があります。

インスタンス作成後のより複雑なステップを行う前に、[バリデーションレイヤー](!ja/三角形を描く/セットアップ/バリデーションレイヤー)をチェックしてデバッグオプションを評価してみましょう！

[C++ コード](/code/01_instance_creation.cpp)
