## 物理デバイスの選択

VkInstanceでVulkanライブラリを初期化した後、必要な機能をサポートするグラフィックカードをシステム内で探して選択する必要があります。実際には何枚でも選択して同時に使用することができますが、このチュートリアルでは必要な機能をサポートしている最初のグラフィックスカードを選択することにします。

`pickPhysicalDevice` 関数を追加し、`initVulkan` 関数でその呼び出します。

```c++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    pickPhysicalDevice();
}

void pickPhysicalDevice() {

}
```

最終的に選択するグラフィックスカードは、新しいクラスメンバとして追加した`VkPhysicalDevice`ハンドルに格納されます。このオブジェクトは`VkInstance`が破棄されると暗黙のうちに破棄されるので、`cleanup`関数で新たに何かをする必要はありません。

```c++
VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;
```

グラフィックカードの一覧取得はエクステンションのリストと非常に似ており、まず数だけを問い合わせます。

```c++
uint32_t deviceCount = 0;
vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr);
```

Vulkanをサポートしているデバイスが0個であれば、これ以上先に進む意味はありません。

```c++
if (deviceCount == 0) {
    throw std::runtime_error("failed to find GPUs with Vulkan support!");
}
```

そうでなければ、VkPhysicalDevice のすべてのハンドルを保持ため、配列を割り当てます。

```c++
std::vector<VkPhysicalDevice> devices(deviceCount);
vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data());
```

すべてのグラフィックカードが同じように作られているわけではないので、それぞれを評価して、実行したい操作に適しているかどうかをチェックする必要があります。そのために新しい関数を導入します。

```c++
bool isDeviceSuitable(VkPhysicalDevice device) {
    return true;
}
```

そして、要件を満たしている物理デバイスがあるかどうかをチェックします。

```c++
for (const auto& device : devices) {
    if (isDeviceSuitable(device)) {
        physicalDevice = device;
        break;
    }
}

if (physicalDevice == VK_NULL_HANDLE) {
    throw std::runtime_error("failed to find a suitable GPU!");
}
```

次のセクションでは、`isDeviceSuitable`関数でチェックする最初の要件を追加します。後の章ではより多くのVulkanの機能を使うようになるので、この関数を拡張してより多くのチェックを行う予定です。

## ベースデバイスの適合性チェック

デバイスの適合性を評価するには、いくつかの詳細を問い合わせることから始めることができます。名前、タイプ、サポートされているVulkanのバージョンなどの基本的なデバイスのプロパティは、`vkGetPhysicalDeviceProperties` を使用して問い合わせることができます。

```c++
VkPhysicalDeviceProperties deviceProperties;
vkGetPhysicalDeviceProperties(device, &deviceProperties);
```

テクスチャ圧縮、64ビット浮動小数点数、マルチビューポートレンダリング（VR に便利）などのオプション機能のサポートは、`vkGetPhysicalDeviceFeatures` を使用して問い合わせることができます。

```c++
VkPhysicalDeviceFeatures deviceFeatures;
vkGetPhysicalDeviceFeatures(device, &deviceFeatures);
```

デバイスから取得できる詳細はもっとあります。デバイスメモリやキューファミリーについては後ほど説明します。（次のセクションを参照）

例として、ジオメトリシェーダをサポートする専用のグラフィックスカードでのみ使用可能なアプリケーションを考えてみましょう。そうすると、`isDeviceSuitable` 関数は次のようになります。

```c++
bool isDeviceSuitable(VkPhysicalDevice device) {
    VkPhysicalDeviceProperties deviceProperties;
    VkPhysicalDeviceFeatures deviceFeatures;
    vkGetPhysicalDeviceProperties(device, &deviceProperties);
    vkGetPhysicalDeviceFeatures(device, &deviceFeatures);

    return deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU &&
           deviceFeatures.geometryShader;
}
```

デバイスが適しているかどうかをチェックして、最初のデバイスを選ぶのではなく、各デバイスにスコアを与えて、最も高いものを選ぶこともできます。このようにして、専用のグラフィックカードに高いスコアを与えることで優遇できますし、統合 GPU が唯一利用可能なものであれば、それにフォールバックすることもできます。次のように実装します。

```c++
#include <map>

...

void pickPhysicalDevice() {
    ...

    // Use an ordered map to automatically sort candidates by increasing score
    std::multimap<int, VkPhysicalDevice> candidates;

    for (const auto& device : devices) {
        int score = rateDeviceSuitability(device);
        candidates.insert(std::make_pair(score, device));
    }

    // Check if the best candidate is suitable at all
    if (candidates.rbegin()->first > 0) {
        physicalDevice = candidates.rbegin()->second;
    } else {
        throw std::runtime_error("failed to find a suitable GPU!");
    }
}

int rateDeviceSuitability(VkPhysicalDevice device) {
    ...

    int score = 0;

    // Discrete GPUs have a significant performance advantage
    if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
        score += 1000;
    }

    // Maximum possible size of textures affects graphics quality
    score += deviceProperties.limits.maxImageDimension2D;

    // Application can't function without geometry shaders
    if (!deviceFeatures.geometryShader) {
        return 0;
    }

    return score;
}
```

このチュートリアルではすべてを実装する必要はありませんが、デバイス選択プロセスをどのように設計するかのアイデアを提供しておきます。もちろん、選択肢を表示してユーザーが選択できるようにすることもできます。

まだ始めたばかりなので、必要なのはVulkanをサポートしていることだけなので、どの GPU でもよいことにします。

```c++
bool isDeviceSuitable(VkPhysicalDevice device) {
    return true;
}
```

次のセクションでは、最初にチェックすべき機能について説明します。

## キューファミリー

以前にも簡単に触れましたが、Vulkanでは、描画からテクスチャのアップロードまで、ほとんどすべての操作が、キューへのコマンドの投入を必要とします。異なる*キューファミリー*に属する異なるタイプのキューがあり、それぞれのキューファミリーはコマンドのサブセットのみを許可します。例えば、計算コマンドの処理のみを許可するキューファミリーや、 メモリ転送に関連するコマンドのみを許可するキューファミリーがあるかもしれません。

どのキューファミリーがデバイスによってサポートされているのか、そして、どのキューファミリーが使いたいコマンドをサポートしているのかをチェックする必要があります。そのために、必要なすべてのキューファミリーを探す新しい関数 `findQueueFamilies` を追加します。

今のところ、私たちはグラフィックコマンドをサポートしているキューを探すだけなので、 この関数は次のようになります。

```c++
uint32_t findQueueFamilies(VkPhysicalDevice device) {
    // Logic to find graphics queue family
}
```

しかし、次の章では、すでに別のキューを探すことになっているので、 それに備えてインデックスを構造体に束ねておく方が良いでしょう。

```c++
struct QueueFamilyIndices {
    uint32_t graphicsFamily;
};

QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {
    QueueFamilyIndices indices;
    // Logic to find queue family indices to populate struct with
    return indices;
}
```

しかし、もしキューファミリーが利用できない場合はどうすればいいのでしょうか？ `findQueueFamilies`で例外を投げることもできますが、この関数はデバイスの適合性を判断するのに適していません。例えば、専用の転送キューファミリーを持つデバイス出会ったほうが良くても、必ずしもそれを必要としないかもしれません。したがって、特定のキューファミリーが見つかったかどうかを示す何らかの方法が必要です。

キューファミリーが存在しないことを示すマジックナンバーを使うことは、実際には不可能です。なぜなら、`uint32_t` のどの値も、理論的には `0` を含む有効なキューファミリーインデックスになり得るからです。幸いなことに、C++17 では、値が存在する場合としない場合を区別するためのデータ構造が導入されています。

```c++
#include <optional>

...

std::optional<uint32_t> graphicsFamily;

std::cout << std::boolalpha << graphicsFamily.has_value() << std::endl; // false

graphicsFamily = 0;

std::cout << std::boolalpha << graphicsFamily.has_value() << std::endl; // true
```

`std::optional` は、何かを代入するまで値を持たないラッパーです。どの時点でも `has_value()` メンバ関数を呼び出すことで、値が含まれているかどうかを問い合わせることができます。よって、ロジックを次のように変更しましょう。

```c++
#include <optional>

...

struct QueueFamilyIndices {
    std::optional<uint32_t> graphicsFamily;
};

QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {
    QueueFamilyIndices indices;
    // Assign index to queue families that could be found
    return indices;
}
```

これで実際に `findQueueFamilies` を実装することができるようになりました。

```c++
QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {
    QueueFamilyIndices indices;

    ...

    return indices;
}
```

キューファミリーのリストを取得するプロセスは、予想通り `vkGetPhysicalDeviceQueueFamilyProperties` を使用します。

```c++
uint32_t queueFamilyCount = 0;
vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr);

std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount);
vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data());
```

VkQueueFamilyProperties 構造体には、サポートされている操作の種類や、そのファミリーに基づいて作成できるキューの数など、キューファミリーに関する詳細が含まれています。`VK_QUEUE_GRAPHICS_BIT` をサポートしているキューファミリーを少なくとも一つ見つける必要があります。

```c++
int i = 0;
for (const auto& queueFamily : queueFamilies) {
    if (queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
        indices.graphicsFamily = i;
    }

    i++;
}
```

これで、高機能なキューファミリー検索関数が手に入ったので、これを `isDeviceSuitable` 関数のチェックとして利用して、デバイスが使いたいコマンドを処理できるかどうかを確認することができます。

```c++
bool isDeviceSuitable(VkPhysicalDevice device) {
    QueueFamilyIndices indices = findQueueFamilies(device);

    return indices.graphicsFamily.has_value();
}
```

これをもう少し便利にするために、構造体自体に汎用的なチェックを追加します。
struct itself:

```c++
struct QueueFamilyIndices {
    std::optional<uint32_t> graphicsFamily;

    bool isComplete() {
        return graphicsFamily.has_value();
    }
};

...

bool isDeviceSuitable(VkPhysicalDevice device) {
    QueueFamilyIndices indices = findQueueFamilies(device);

    return indices.isComplete();
}
```

これを使って `findQueueFamilies` からの見つかり次第break出来るようになりました。

```c++
for (const auto& queueFamily : queueFamilies) {
    ...

    if (indices.isComplete()) {
        break;
    }

    i++;
}
```

いいですね、これで正しい物理デバイスを見つけるのに必要なものはすべて揃いました。次のステップは、物理デバイスとインターフェースする[論理デバイスを作成](!ja/三角形を描く/セットアップ/論理デバイスとキュー)することです。

[C++ コード](/code/03_physical_device_selection.cpp)
