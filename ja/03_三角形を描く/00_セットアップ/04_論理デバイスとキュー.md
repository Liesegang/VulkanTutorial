## はじめに

使用する物理デバイスを選択した後、それとインターフェースするための*論理デバイス*をセットアップする必要があります。論理デバイスの作成プロセスは、インスタンスの作成プロセスと似ており、使いたい機能を記述します。また、どのキューファミリーが利用可能かを問い合わせたので、次はどのキューを作成するかを指定する必要があります。要求が異なる場合は、同じ物理デバイスから複数の論理デバイスを作成することもできます。

まず、論理デバイスのハンドルを格納するための新しいクラスメンバを追加することから始めましょう。

```c++
VkDevice device;
```

次に、`initVulkan` から呼び出される `createLogicalDevice` 関数を追加します。

```c++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    pickPhysicalDevice();
    createLogicalDevice();
}

void createLogicalDevice() {

}
```

## 作成するキューの指定

論理デバイスの作成には、構造体に多くの詳細を再び指定する必要があります。最初のものは `VkDeviceQueueCreateInfo` です。この構造体は、単一のキューファミリーに対して必要なキューの数を記述します。今のところ、私たちが必要なのはグラフィック機能を持つキューだけです。

```c++
QueueFamilyIndices indices = findQueueFamilies(physicalDevice);

VkDeviceQueueCreateInfo queueCreateInfo{};
queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
queueCreateInfo.queueFamilyIndex = indices.graphicsFamily.value();
queueCreateInfo.queueCount = 1;
```

現在利用可能なドライバでは、各キューファミリーに対して少数のキューを作成することしかできませんし、実際には複数のキューを作成する必要はありません。それは、複数のスレッド上にすべてにコマンドバッファを作成し、単一の低いオーバーヘッドのコールを用いてメインスレッド上で一度にすべてのコマンドバッファを投入できるからです。

Vulkanでは、コマンドバッファ実行のスケジューリングにおいて、`0.0` から `1.0` の間の浮動小数点数を与えることで、キューに優先度を割り当てることができます。これは、キューが1つしかない場合でも必要です。

```c++
float queuePriority = 1.0f;
queueCreateInfo.pQueuePriorities = &queuePriority;
```

## 使用するデバイスの機能の指定

次に指定する情報は、使用するデバイス機能のセットです。これらは前の章で `vkGetPhysicalDeviceFeatures` でサポートを問い合わせた機能で、例えばジオメトリシェーダのようなものです。今のところ特別なものは必要ないので、`VK_FALSE` のままにしておきましょう。この構造体については、Vulkan を使ってもっと面白いことを始めるときに、また説明します。

```c++
VkPhysicalDeviceFeatures deviceFeatures{};
```

## 論理デバイスの作成

前の2つの構造体が作成されたので、メインの `VkDeviceCreateInfo` 構造体への割り当てることが出来ます。

```c++
VkDeviceCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
```

最初に、QueueCreateInfosとVkPhysicalDeviceFeatures構造体へのポインタを追加します。

```c++
createInfo.pQueueCreateInfos = &queueCreateInfo;
createInfo.queueCreateInfoCount = 1;

createInfo.pEnabledFeatures = &deviceFeatures;
```

残りの情報は `VkInstanceCreateInfo` 構造体に似ており、エクステンションとバリデーションレイヤーを指定します。前のものとの違いは、これらがデバイス固有のものであることです。

デバイス固有のエクステンションの例としては `VK_KHR_swapchain` があります。これを利用することで、そのデバイスでレンダリングした画像をウィンドウに表示することができます。システム内にこの機能を持たない Vulkan デバイスが存在する可能性があります。例えば、計算命令のみをサポートするようなものです。このエクステンションについてはスワップチェーンの章で説明します。

以前のVulkanの実装では、インスタンス固有のバリデーションレイヤーとデバイス固有のバリデーションレイヤーを区別していましたが、[今はそうではなくなりました](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#extendingvulkan-layers-devicelayerdeprecation)。つまり、`VkDeviceCreateInfo` の `enabledLayerCount` と `ppEnabledLayerNames` フィールドは最新の実装では無視されます。しかし、古い実装との互換性を保つために、いずれにしてもこれらを設定しておくと良いでしょう。

```c++
createInfo.enabledExtensionCount = 0;

if (enableValidationLayers) {
    createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());
    createInfo.ppEnabledLayerNames = validationLayers.data();
} else {
    createInfo.enabledLayerCount = 0;
}
```

今のところ、デバイス固有のエクステンションは必要ないでしょう。

以上で、`vkCreateDevice` 関数を呼び出して論理デバイスのインスタンスを作成する準備が整いました。

```c++
if (vkCreateDevice(physicalDevice, &createInfo, nullptr, &device) != VK_SUCCESS) {
    throw std::runtime_error("failed to create logical device!");
}
```

パラメータは、インターフェイスする物理デバイス、先ほど指定したキューと使用状況情報、オプションのアロケーションコールバックポインタ、論理デバイスハンドルを格納する変数へのポインタです。インスタンス作成関数と同様に、この呼び出しは存在しないエクステンションを有効にしたり、サポートされていない機能の使用を指定したりした場合にエラーを返すことがあります。

デバイスは `cleanup` で `vkDestroyDevice` 関数を使って破棄しなければなりません。

```c++
void cleanup() {
    vkDestroyDevice(device, nullptr);
    ...
}
```

論理デバイスはインスタンスと直接対話することはありません。そのため、パラメータにはインスタンスは含まれていません。

## キューハンドルの取得

キューは論理デバイスと一緒に自動的に作成されますが、それらとインターフェイスするためのハンドルをまだ持っていません。まず、グラフィックスキューへのハンドルを格納するクラスメンバを追加します。

```c++
VkQueue graphicsQueue;
```

デバイスキューはデバイスが破棄されると暗黙のうちにクリーンアップされるので、`cleanup`で何もする必要はありません。

キューファミリーごとにキューハンドルを取得するには、`vkGetDeviceQueue` 関数を使います。パラメータは、論理デバイス、キューファミリー、キューインデックス、そしてキューハンドルを格納する変数へのポインタです。このファミリからは単一のキューしか作成していないので、インデックスは単純に `0` を使用します。

```c++
vkGetDeviceQueue(device, indices.graphicsFamily.value(), 0, &graphicsQueue);
```

論理デバイスとキューハンドルができたので、これで実際にグラフィックカードを使って何かをすることができるようになりました！次からのいくつかの章では、結果をウィンドウシステムに表示するためのリソースを設定します。

[C++ コード](/code/04_logical_device.cpp)
