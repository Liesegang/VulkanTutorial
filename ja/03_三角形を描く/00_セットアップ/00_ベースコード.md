## 全体の構造

前の章では、Vulkanプロジェクトを作成し、プロジェクトを適切に設定し、サンプルコードでテストしました。この章では、以下のコードを使ってゼロまたゼロから始めます。

```c++
#include <vulkan/vulkan.h>

#include <iostream>
#include <stdexcept>
#include <cstdlib>

class HelloTriangleApplication {
public:
    void run() {
        initVulkan();
        mainLoop();
        cleanup();
    }

private:
    void initVulkan() {

    }

    void mainLoop() {

    }

    void cleanup() {

    }
};

int main() {
    HelloTriangleApplication app;

    try {
        app.run();
    } catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
```

まず、関数、構造体、列挙子を提供するLunarG SDKのVulkanヘッダをインクルードします。エラーの報告と伝播のために `stdexcept` と `iostream` ヘッダをインクルードします。`cstdlib` ヘッダは `EXIT_SUCCESS` と `EXIT_FAILURE` マクロを提供します。

プログラム自体はクラスにラップされており、Vulkanオブジェクトをプライベートクラスのメンバとして格納しています。そこに`initVulkan`関数から呼び出されるそれぞれの関数を追加していきます。すべての準備ができたら、メインループに入ってフレームのレンダリングを開始します。ここでは、`mainLoop` 関数に、ウィンドウが閉じるまで反復処理を行うループを追加します。ウィンドウが閉じて `mainLoop` がreturnしたら、`cleanup` 関数で使用したリソースを解放します。

実行中に何らかの致命的なエラーが発生した場合は、`std::runtime_error` 例外をスローし、エラーを説明するメッセージとともに `main` 関数にエラーを伝搬してコマンドプロンプトに出力します。様々な標準的な例外タイプを扱うために、より一般的な `std::exception` をキャッチします。近いうちに扱うことになるエラーの例としては、必要なエクステンションがサポートされていないことが判明したエラーがあります。

おおまかには、この章以降の各章では、`initVulkan`から呼び出される新しい関数1つと、`cleanup`で最後に解放する必要がある1つ以上の新しいVulkanオブジェクトがクラスのプライベートメンバに追加される予定です。

## リソース管理

`malloc`で割り当てられたメモリの各チャンクが `free` の呼び出しを必要とするのと同じように、作成したすべてのVulkanオブジェクトは不要になったら明示的に破棄する必要があります。C++では、`<memory>`ヘッダで提供される[RAII](https://ja.wikipedia.org/wiki/RAII)やスマートポインタを使って自動的にリソースを管理することができます。しかし、このチュートリアルでは、Vulkanオブジェクトの割り当てと解放について明示的に説明することにしました。結局のところ、Vulkanの強みは、ミスを避けるためにすべての操作について明示できることであるので、APIがどのように動作するかを学ぶためにオブジェクトの寿命について明示するのは良いことです。

このチュートリアルを終えたあとに、コンストラクタでVulkanオブジェクトを取得し、デストラクタで解放するC++クラスを書くことで、または、`std::unique_ptr` や `std::shared_ptr` にカスタムデリータを実装することで、自動リソース管理を実装することができるでしょう。 RAIIは大規模なVulkanプログラムには推奨されるモデルですが、学習のためには裏で何が行われているのかを知ることは良いことです。

Vulkanオブジェクトは、`vkCreateXXX`のような関数で直接作成されるか、`vkAllocateXXX`のような関数で別のオブジェクトを介して割り当てられます。オブジェクトがどこでも使われなくなったことを確認したら、`vkDestroyXXX` や `vkFreeXXX` などの関数を使ってオブジェクトを破棄する必要があります。これらの関数のパラメータは一般的にオブジェクトの種類によって異なりますが、共通するパラメータが一つあります。それは `pAllocator` です。これはオプションのパラメータで、カスタムメモリアロケータのコールバックを指定することができます。チュートリアルではこのパラメータは無視して、常に `nullptr` を引数に渡します。

## GLFWの統合

オフスクリーンレンダリングに使いたい場合は、ウィンドウを作成しなくてもVulkanは完璧に動作しますが、実際に何かを表示する方がはるかに面白いです。まず、`#include <vulkan/vulkan.h>` の行を次のように置き換えてください。

```c++
#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>
```

そうすれば、GLFWは独自の定義を含めて自動的にVulkanヘッダを読み込んでくれます。関数 `initWindow` を追加し、他の呼び出しの前の位置に `run` 関数からの呼び出しを追加します。その関数を使ってGLFWを初期化し、ウィンドウを作成します。

```c++
void run() {
    initWindow();
    initVulkan();
    mainLoop();
    cleanup();
}

private:
    void initWindow() {

    }
```

`initWindow`で最初に呼び出すべき関数は、GLFWライブラリを初期化する `glfwInit()` です。GLFWはもともとOpenGLコンテキストを作成するように設計されているので、後に続く関数呼び出しでOpenGLコンテキストを作成しないように指示する必要があります。

```c++
glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
```

ウィンドウのリサイズを処理するには、後述する特別な注意が必要なので、さらに `glfwWindowHint` 関数を呼び出し、今のところはこれを無効にしてください。

```c++
glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
```

あとは、実際のウィンドウを作成するだけです。　`GLFWwindow* window;`をプライベートクラスのメンバに追加して参照を保持し、以下のようにウィンドウを初期化します。

```c++
window = glfwCreateWindow(800, 600, "Vulkan", nullptr, nullptr);
```

最初の3つのパラメータは、ウィンドウの幅、高さ、タイトルを指定します。4番目のパラメータは、オプションでウィンドウを開くモニターを指定することができ、最後のパラメータはOpenGLにだけに関連するものです。

今後、幅と高さの値を何度か参照することになるので、ハードコードする代わりに定数を使用しましょう。私は、`HelloTriangleApplication`クラス定義の上に以下の行を追加しました。

```c++
const uint32_t WIDTH = 800;
const uint32_t HEIGHT = 600;
```

そして、ウィンドウ作成の関数呼び出しを以下で置き換えます。

```c++
window = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan", nullptr, nullptr);
```

これで、以下のような `initWindow` 関数ができたはずです。

```c++
void initWindow() {
    glfwInit();

    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

    window = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan", nullptr, nullptr);
}
```

エラーが発生するかウィンドウが閉じられるまでアプリケーションを実行し続けるためには、以下のように `mainLoop` 関数にイベントループを追加する必要があります。

```c++
void mainLoop() {
    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();
    }
}
```

このコードはかなりわかりやすいはずです。このコードはループして、ユーザによってウィンドウが閉じられるまでXボタンを押すなどのイベントをチェックします。これは後に1つのフレームをレンダリングするための関数を呼び出すループでもあります。

ウィンドウが閉じられたら、ウィンドウを破棄してGLFW自体を終了させることでリソースをクリーンアップする必要があります。以下が最初のクリーンアップコードになります。

```c++
void cleanup() {
    glfwDestroyWindow(window);

    glfwTerminate();
}
```

プログラムを実行すると、ウィンドウを閉じてアプリケーションが終了するまで `Vulkan` というタイトルのウィンドウが表示されるはずです。これでVulkanアプリケーションの骨格ができたので、[最初のVulkanオブジェクトを作成](!ja/三角形を描く/セットアップ/インスタンス)してみましょう。

[C++ コード](/code/00_base_code.cpp)
