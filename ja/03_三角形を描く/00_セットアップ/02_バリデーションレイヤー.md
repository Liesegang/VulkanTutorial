## バリデーションレイヤーとはなにか？

Vulkan APIはドライバのオーバーヘッドを最小限に抑えるという考えに基づいて設計されており、その目標の現れの一つとして、APIのエラーチェックがデフォルトで非常に制限されていることが挙げられます。列挙子に不正な値を設定したり、必要なパラメータにnullポインタを渡したりするような単純なミスでも、一般的には明示的には処理されず、単にクラッシュや未定義の動作を引き起こします。Vulkanは何をしているかについて非常に明確にすることを要求するので、新しいGPU機能を使用して、論理デバイスの作成時に要求するのを忘れてしまうような小さなミスをたくさん犯してしまいがちです。

しかし、だからといってこれらのチェックをAPIに追加できないわけではありません。Vulkanは、*バリデーションレイヤー*として知られるエラーチェックのためのエレガントなシステムを導入しています。バリデーションレイヤーは、Vulkanの関数呼び出しにフックして追加の操作を適用するオプションのコンポーネントです。バリデーションレイヤーの一般的な動作は以下の通りです。

* 誤用を検出するため仕様に合致するか、パラメータの値をチェックする
* リソースリークを検出するためオブジェクトの生成と破壊を追跡する
* 呼び出し元のスレッドを追跡することによってスレッドの安全性をチェックする
* すべての呼び出しとそのパラメータを標準出力に記録する
* プロファイリングとリプレイのためVulkan呼び出しを追跡する

ここでは、診断バリデーションレイヤーでの関数の実装がどのようか例を示します。

```c++
VkResult vkCreateInstance(
    const VkInstanceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance* instance) {

    if (pCreateInfo == nullptr || instance == nullptr) {
        log("Null pointer passed to required parameter!");
        return VK_ERROR_INITIALIZATION_FAILED;
    }

    return real_vkCreateInstance(pCreateInfo, pAllocator, instance);
}
```

これらのバリデーションレイヤーは自由にスタックして、興味のあるすべてのデバッグ機能を含めることができます。デバッグビルドではバリデーションレイヤーを有効にし、リリースビルドではバリデーションレイヤーを完全に無効にすることができます。

Vulkanにはバリデーションレイヤーは組み込まれていませんが、LunarG Vulkan SDKには一般的なエラーをチェックするための優れたレイヤーが用意されています。また、これらのレイヤーは完全に[オープンソース](https://github.com/KhronosGroup/Vulkan-ValidationLayers)であるため、どのような間違いでもチェックして貢献することができます。バリデーションレイヤーを使用することは、定義されていない動作に誤って行うことで、アプリケーションが異なるドライバ上で動作しなくなることを避けるための最良の方法です。

バリデーションレイヤーは、システムにインストールされている場合にのみ使用することができます。例えば、LunarGのバリデーションレイヤーは、Vulkan SDKがインストールされたPCでのみ利用可能です。

以前は、Vulkanにはインスタンス用とデバイス用の2種類のバリデーションレイヤーがありました。インスタンスレイヤーはインスタンスのようなグローバルなVulkanオブジェクトに関連する呼び出しのみをチェックし、デバイス固有のレイヤーは特定のGPUに関連する呼び出しのみをチェックするという考えでした。デバイス固有のレイヤは現在非推奨となっており、インスタンスバリデーションレイヤーがすべてのVulkanコールに適用されます。仕様書では、未だに互換性のためにデバイスレベルでもバリデーションレイヤーを有効にすることを推奨していますが、これは一部の実装で必要とされているだけです。後ほど説明する論理デバイスレベルでインスタンスと同じレイヤを指定するだけです。単純に論理デバイスレベルでインスタンスと同じレイヤを指定するだけですが、これは[後述します](!ja/三角形を描く/セットアップ/論理デバイスとキュー)。

## バリデーションレイヤーの使用

このセクションでは、Vulkan SDKが提供する標準の診断レイヤを有効にする方法を見ていきます。エクステンションと同様に、バリデーションレイヤーも名前を指定して有効にする必要があります。有用で標準的なバリデーションはすべて、SDKに組み込まれている `VK_LAYER_KHRONOS_validation` という名前のレイヤーにバンドルされています。

まず、プログラムに2つの設定用の変数を追加して、有効にするレイヤーと有効にするかどうかを指定します。この値は、プログラムがデバッグモードでコンパイルされているかどうかを基準にしています。マクロ `NDEBUG` は C++ 標準の一部で、「デバッグしない」という意味です。

```c++
const uint32_t WIDTH = 800;
const uint32_t HEIGHT = 600;

const std::vector<const char*> validationLayers = {
    "VK_LAYER_KHRONOS_validation"
};

#ifdef NDEBUG
    const bool enableValidationLayers = false;
#else
    const bool enableValidationLayers = true;
#endif
```

要求されたすべてのレイヤーが利用可能かどうかをチェックする新しい関数 `checkValidationLayerSupport` を追加します。まず、`vkEnumerateInstanceLayerProperties` 関数を用いて利用可能なすべてのレイヤーをリストアップします。この関数の使い方は、インスタンス作成の章で説明した `vkEnumerateInstanceExtensionProperties` と同じです。

```c++
bool checkValidationLayerSupport() {
    uint32_t layerCount;
    vkEnumerateInstanceLayerProperties(&layerCount, nullptr);

    std::vector<VkLayerProperties> availableLayers(layerCount);
    vkEnumerateInstanceLayerProperties(&layerCount, availableLayers.data());

    return false;
}
```

次に、`validationLayers` のすべてのレイヤーが `availableLayers` リストに存在するかどうかを確認します。この際、`strcmp` のために `<cstring>` をインクルードする必要があるでしょう。

```c++
for (const char* layerName : validationLayers) {
    bool layerFound = false;

    for (const auto& layerProperties : availableLayers) {
        if (strcmp(layerName, layerProperties.layerName) == 0) {
            layerFound = true;
            break;
        }
    }

    if (!layerFound) {
        return false;
    }
}

return true;
```

これで、`createInstance`でこの関数を使うことができるようになりました。

```c++
void createInstance() {
    if (enableValidationLayers && !checkValidationLayerSupport()) {
        throw std::runtime_error("validation layers requested, but not available!");
    }

    ...
}
```

デバッグモードでプログラムを実行して、エラーが発生しないことを確認してください。エラーが発生した場合は、FAQを参照してください。

最後に、`VkInstanceCreateInfo` 構造体のインスタンス化を、バリデーションレイヤー名が有効になっている場合はバリデーションレイヤーを含むように修正します。

```c++
if (enableValidationLayers) {
    createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());
    createInfo.ppEnabledLayerNames = validationLayers.data();
} else {
    createInfo.enabledLayerCount = 0;
}
```

チェックが成功した場合、`vkCreateInstance` は `VK_ERROR_LAYER_NOT_PRESENT` エラーを返すことはありませんが、プログラムを実行して確認したほうが良いでしょう。

## メッセージコールバック

バリデーションレイヤーはデフォルトでデバッグメッセージを標準出力に出力しますが、プログラム内で明示的なコールバックを提供することで、デバッグメッセージを自分で処理することもできます。これにより、どのようなメッセージを表示するかを決めることができます。今これを行いたくない場合は、この章の最後のセクションまで読み飛ばしてください。

メッセージや関連する詳細を処理するためのコールバックをプログラムに設定するには、`VK_EXT_debug_utils` エクステンションを使ってコールバックを持つデバッグメッセンジャーを設定しなければなりません。

まず最初に `getRequiredExtensions` 関数を作成して、バリデーションレイヤーが有効かどうかに応じて必要なエクステンションのリストを返します。

```c++
std::vector<const char*> getRequiredExtensions() {
    uint32_t glfwExtensionCount = 0;
    const char** glfwExtensions;
    glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

    std::vector<const char*> extensions(glfwExtensions, glfwExtensions + glfwExtensionCount);

    if (enableValidationLayers) {
        extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
    }

    return extensions;
}
```

GLFWで指定されたエクステンションは常に必須ですが、デバッグメッセンジャーのエクステンションは条件に応じて追加されます。ここでは `VK_EXT_DEBUG_UTILS_EXTENSION_NAME` マクロを使用していますが、これはリテラル文字列 "VK_EXT_DEBUG_UTILS" と定義されています。このマクロを使うことでタイプミスを防ぐことができます。

これで、`createInstance`でこの関数を使うことができるようになりました。

```c++
auto extensions = getRequiredExtensions();
createInfo.enabledExtensionCount = static_cast<uint32_t>(extensions.size());
createInfo.ppEnabledExtensionNames = extensions.data();
```

プログラムを実行して `VK_ERROR_EXTENSION_NOT_PRESENT` エラーが出ないことを確認します。このエクステンションが存在するかどうかを確認する必要はありません。なぜなら、バリデーションレイヤーが利用可能であるか確認することで暗黙的に行われるからです。

それでは、デバッグ用のコールバック関数がどのようなものか見てみましょう。`PFN_vkDebugUtilsMessengerCallbackEXT`プロトタイプを用いて `debugCallback` という新しい静的メンバ関数を追加します。`VKAPI_ATTR` と `VKAPI_CALL` は、この関数が Vulkan がそれを呼び出すための正しいシグネチャを持っていることを保証します。

```c++
static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback(
    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT messageType,
    const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,
    void* pUserData) {

    std::cerr << "validation layer: " << pCallbackData->pMessage << std::endl;

    return VK_FALSE;
}
```

最初のパラメータはメッセージの深刻度を指定します。以下の種類のフラグがあります。

* `VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT`: 診断メッセージ
* `VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT`: リソースの作成などの情報メッセージ
* `VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT`: 必ずしもエラーではないが、アプリケーションのバグである可能性が高い動作についてのメッセージ
* `VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT`: 無効であり、クラッシュの原因となる可能性のある動作についてのメッセージ

この列挙の値は、例えばあるレベルの深刻度と比較してメッセージの深刻度がそれ以上に悪いかをチェックするために比較操作をするため設定されています。

```c++
if (messageSeverity >= VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) {
    // Message is important enough to show
}
```

`messageType` パラメータには以下の値を指定できます。

* `VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT`: 仕様やパフォーマンスに関係のないイベントが発生した
* `VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT`: 仕様に違反しているか、間違いの可能性があるイベントが発生した
* `VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT`: 最適でない可能性があるVulkanの使用

`pCallbackData` パラメータは、メッセージ自体の詳細を含む `VkDebugUtilsMessengerCallbackDataEXT` 構造体を参照します。最も重要なメンバは以下のとおりです。

* `pMessage`: ヌル文字で終端する文字列によるデバッグメッセージ
* `pObjects`: メッセージに関連するVulkanオブジェクトハンドルの配列
* `objectCount`: 配列に含まれるオブジェクトの数

最後に、`pUserData`パラメータには、コールバックの設定時に指定したポインタが含まれており、自分のデータを渡すことができます。

コールバックはバリデーションレイヤーメッセージのトリガーとなったVulkanコールを中止すべきかどうかを示すブール値を返します。コールバックが true を返した場合、`VK_ERROR_VALIDATION_FAILED_EXT` エラーで中止されます。これは通常、バリデーションレイヤー自体をテストするためにのみ使用されるので、常に `VK_FALSE` を返すべきです。

あとはコールバック関数をVulkanに伝えるだけです。おそらくやや驚くべきことに、Vulkanのデバッグコールバックでさえ、明示的に作成して破棄する必要のあるハンドルで管理されています。このようなコールバックは *デバッグメッセンジャー* の一部であり、必要な数だけ持つことができます。このハンドルを保持するクラスメンバを `instance` の直下に追加します。

```c++
VkDebugUtilsMessengerEXT debugMessenger;
```

そして、関数 `setupDebugMessenger` を追加し、`createInstance` の直後に `initVulkan` から呼び出されるようにします。

```c++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
}

void setupDebugMessenger() {
    if (!enableValidationLayers) return;

}
```

メッセンジャーとそのコールバックに関する詳細を構造体に設定する必要があります。

```c++
VkDebugUtilsMessengerCreateInfoEXT createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
createInfo.pfnUserCallback = debugCallback;
createInfo.pUserData = nullptr; // Optional
```

`messageSeverity` フィールドでは、コールバックを呼び出したいすべての深刻度のタイプをすべて指定します。ここでは、一般的な詳細デバッグ情報を省略し、起こりうる問題についての通知を受け取ることができるように `VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT` を除いたすべてのタイプを指定しています。

同様に、`messageType` フィールドでは、コールバックが通知するメッセージの種類をフィルタリングすることができます。ここでは、すべてのタイプを有効にしています。役に立たない場合は、いつでも無効にすることができます。

最後に、`pfnUserCallback` フィールドはコールバック関数へのポインタを指定します。オプションで `pUserData` フィールドへのポインタを渡すことができ、このポインタは `pUserData` パラメータを通じてコールバック関数に渡されます。これを使って、例えば `HelloTriangleApplication` クラスへのポインタを渡すことができます。

バリデーションレイヤーのメッセージやデバッグコールバックを設定する方法は他にもたくさんありますが、このチュートリアルを始めるにはこの設定が良いでしょう。他の可能性についての詳細は[エクステンションの仕様](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_debug_utils)を参照してください。

この構造体を `vkCreateDebugUtilsMessengerEXT` 関数に渡して、`VkDebugUtilsMessengerEXT` オブジェクトを作成する必要があります。残念ながら、この関数は拡張関数なので、自動的に読み込まれるわけではありません。自分で `vkGetInstanceProcAddr` を使ってアドレスを調べる必要があります。これをバックグラウンドで処理する独自のプロキシ関数を作成します。これを `HelloTriangleApplication` クラス定義のすぐ上に追加しました。

```c++
VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger) {
    auto func = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, "vkCreateDebugUtilsMessengerEXT");
    if (func != nullptr) {
        return func(instance, pCreateInfo, pAllocator, pDebugMessenger);
    } else {
        return VK_ERROR_EXTENSION_NOT_PRESENT;
    }
}
```

`vkGetInstanceProcAddr` 関数は関数がロードできなかった場合に `nullptr` を返します。これで、拡張オブジェクトが利用可能であれば、この関数を呼び出して作成することができるようになりました。

```c++
if (CreateDebugUtilsMessengerEXT(instance, &createInfo, nullptr, &debugMessenger) != VK_SUCCESS) {
    throw std::runtime_error("failed to set up debug messenger!");
}
```

最後から2番目のパラメータは、オプションのアロケータコールバックで、`nullptr` に設定しました。それ以外のパラメータはわかりやすいでしょう。デバッグメッセンジャーはVulkanインスタンスとそのレイヤに固有のものなので、第一引数に明示的にインスタンスを指定する必要があります。このパターンは、後に他の*子*オブジェクトでも見られます。

`VkDebugUtilsMessengerEXT` オブジェクトも `vkDestroyDebugUtilsMessengerEXT` を呼び出してクリーンアップする必要があります。この関数も`vkCreateDebugUtilsMessengerEXT`と同様に、明示的にロードする必要があります。

`CreateDebugUtilsMessengerEXT`のすぐ下に別のプロキシ関数を作成します。

```c++
void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, const VkAllocationCallbacks* pAllocator) {
    auto func = (PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, "vkDestroyDebugUtilsMessengerEXT");
    if (func != nullptr) {
        func(instance, debugMessenger, pAllocator);
    }
}
```

この関数が静的クラス関数かクラス外の関数にしてください。これを `cleanup` 関数で呼び出すことができます。

```c++
void cleanup() {
    if (enableValidationLayers) {
        DestroyDebugUtilsMessengerEXT(instance, debugMessenger, nullptr);
    }

    vkDestroyInstance(instance, nullptr);

    glfwDestroyWindow(window);

    glfwTerminate();
}
```

## インスタンスの作成と破棄のデバッグ

プログラムにバリデーションレイヤーを使ったデバッグを追加しましたが、まだすべてをカバーしているわけではありません。`vkCreateDebugUtilsMessengerEXT`コールでは、有効なインスタンスが作成されている必要があり、インスタンスが破棄される前に`vkDestroyDebugUtilsMessengerEXT`が呼ばれなければなりません。このため、現在のところ `vkCreateInstance` と `vkDestroyInstance` コールの問題をデバッグすることができません。

しかし、[エクステンションのドキュメント](https://github.com/KhronosGroup/Vulkan-Docs/blob/master/appendices/VK_EXT_debug_utils.txt#L120)をよく読むと、これら二つの関数呼び出しのために別のデバッグ用メッセンジャーを作成する方法があることがわかります。それには、`VkInstanceCreateInfo` の拡張フィールド `pNext` に `VkDebugUtilsMessengerCreateInfoEXT` 構造体へのポインタを渡す必要があります。まず、メッセンジャー作成のための情報を登録する関数を作成します。

```c++
void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT& createInfo) {
    createInfo = {};
    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
    createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
    createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
    createInfo.pfnUserCallback = debugCallback;
}

...

void setupDebugMessenger() {
    if (!enableValidationLayers) return;

    VkDebugUtilsMessengerCreateInfoEXT createInfo;
    populateDebugMessengerCreateInfo(createInfo);

    if (CreateDebugUtilsMessengerEXT(instance, &createInfo, nullptr, &debugMessenger) != VK_SUCCESS) {
        throw std::runtime_error("failed to set up debug messenger!");
    }
}
```

これを `createInstance` 関数で再利用できます。

```c++
void createInstance() {
    ...

    VkInstanceCreateInfo createInfo{};
    createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    createInfo.pApplicationInfo = &appInfo;

    ...

    VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo;
    if (enableValidationLayers) {
        createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());
        createInfo.ppEnabledLayerNames = validationLayers.data();

        populateDebugMessengerCreateInfo(debugCreateInfo);
        createInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*) &debugCreateInfo;
    } else {
        createInfo.enabledLayerCount = 0;

        createInfo.pNext = nullptr;
    }

    if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) {
        throw std::runtime_error("failed to create instance!");
    }
}
```

変数 `debugCreateInfo` は if 文の外側に配置し、`vkCreateInstance` コールの前に破棄されないようにしています。このようにして追加のデバッグメッセンジャーを作成することで、`vkCreateInstance` と `vkDestroyInstance` の間に自動的に使用され、その後にクリーンアップされるようになります。

## テスト

では、わざと間違えてバリデーションレイヤーの動作を見てみましょう。`cleanup` 関数の `DestroyoyDebugUtilsMessengerEXT` の呼び出しを一時的に削除して、プログラムを実行してください。プログラムが終了すると、以下のように表示されるはずです。


![](/images/validation_layer_test.png)

>メッセージが表示されない場合は、[インストールを確認](https://vulkan.lunarg.com/doc/view/1.2.131.1/windows/getting_started.html#user-content-verify-the-installation)してください。

どの呼び出しがメッセージのトリガーとなったかを確認したい場合は、メッセージコールバックにブレークポイントを追加してスタックトレースを見ることができます。

## 設定

`VkDebugUtilsMessengerCreateInfoEXT` 構造体で指定したフラグ以外にも、バリデーションレイヤーの動作に関する設定はたくさんあります。Vulkan SDKを参照して `Config` ディレクトリに移動してください。そこには `vk_layer_settings.txt` ファイルがあり、レイヤーの設定方法を説明しています。

自分のアプリケーション用にレイヤー設定を設定するには、このファイルをプロジェクトの `Debug` ディレクトリと `Release` ディレクトリにコピーして、指示に従って目的の動作を設定してください。しかし、このチュートリアルの残りの部分では、デフォルトの設定を使用していることを想定しています。

このチュートリアルでは、バリデーションレイヤーがバリデーションのキャッチにどれだけ役立つかを示し、Vulkanで何をしているかを正確に知ることがどれだけ重要かを教えるために、意図的にいくつかの間違いを犯します。それでは、[システム内のVulkanデバイス](!ja/三角形を描く/セットアップ/物理デバイスとキューファミリー)を見てみましょう。

[C++ コード](/code/02_validation_layers.cpp)
