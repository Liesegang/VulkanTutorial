過去のいくつかの章でフレームバッファについて多くの説明をしました。スワップチェーンイメージと同じフォーマットの単一のフレームバッファを想定してレンダーパスを設定しましたが、実際にはまだフレームバッファを何も作成していません。

レンダーパスの作成時に指定されたアタッチメントは、`VkFramebuffer` オブジェクトにラップしてバインドされます。フレームバッファオブジェクトはアタッチメントを表す `VkImageView` オブジェクトすべてを参照します。この例では、カラーのアタッチメントの1つだけです。しかし、アタッチメントに使用する画像は、プレゼンテーションのために画像を取得したとき、スワップチェーンがどの画像を返すかに依存します。つまり、スワップチェーン内のすべての画像用のフレームバッファを作成し、描画時に取得した画像に対応するフレームバッファを使用しなければなりません。

そのためには、フレームバッファを保持する `std::vector` 型のクラスメンバを作成します。

```c++
std::vector<VkFramebuffer> swapChainFramebuffers;
```

グラフィックスパイプラインの作成直後に `initVulkan` から呼び出される新しい関数 `createFramebuffers` でこの配列のオブジェクトを作成します。

```c++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
}

...

void createFramebuffers() {

}
```

まず、すべてのフレームバッファを保持出来るようにコンテナのサイズを変更します。

```c++
void createFramebuffers() {
    swapChainFramebuffers.resize(swapChainImageViews.size());
}
```

次に、画像ビューを反復処理してフレームバッファを作成します。

```c++
for (size_t i = 0; i < swapChainImageViews.size(); i++) {
    VkImageView attachments[] = {
        swapChainImageViews[i]
    };

    VkFramebufferCreateInfo framebufferInfo{};
    framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
    framebufferInfo.renderPass = renderPass;
    framebufferInfo.attachmentCount = 1;
    framebufferInfo.pAttachments = attachments;
    framebufferInfo.width = swapChainExtent.width;
    framebufferInfo.height = swapChainExtent.height;
    framebufferInfo.layers = 1;

    if (vkCreateFramebuffer(device, &framebufferInfo, nullptr, &swapChainFramebuffers[i]) != VK_SUCCESS) {
        throw std::runtime_error("failed to create framebuffer!");
    }
}
```

見てきたように、フレームバッファの作成は非常に簡単です。まず、フレームバッファが互換性を持つ `renderPass` を指定する必要があります。互換性のある、つまり大雑把に言えば、同じ数と種類のアタッチメントを使用しているレンダーパスでのみフレームバッファを使用することができます。

`attachmentCount` と `pAttachments` パラメータは、レンダーパスの `pAttachment` 配列内のそれぞれのアタッチメントディスクリプションにバインドする `VkImageView` オブジェクトを指定します。

`width` と `height` パラメータはその名の通りです。`layers` は画像配列のレイヤー数を表します。スワップチェーン画像は単一の画像なので、レイヤーの数は `1` です。

フレームバッファは、それらが基になっている画像ビューとレンダリングパスの前で、レンダリングが終わった後でに削除すべきです。

```c++
void cleanup() {
    for (auto framebuffer : swapChainFramebuffers) {
        vkDestroyFramebuffer(device, framebuffer, nullptr);
    }

    ...
}
```

これで、レンダリングに必要なオブジェクトがすべて揃いました。次の章では、最初の描画コマンドを書いていきます。

[C++ コード](/code/13_framebuffers.cpp) /
[頂点シェーダ](/code/09_shader_base.vert) /
[フラグメントシェーダ](/code/09_shader_base.frag)
