この章ではまず、Vulkanの紹介とその問題点について説明します。その後、最初の三角形を描画するために必要な要素を見ていきます。これにより、その後の各章の全体像を把握することができます。最後に、Vulkan APIの構造と一般的な使用パターンについて説明します。

## Vulkanの起源

これまでのグラフィックスAPIと同様、Vulkanは[GPU](https://ja.wikipedia.org/wiki/Graphics_Processing_Unit)のクロスプラットフォームの抽象化として設計されています。これらのAPIの多くの問題点は、これらのAPIが設計された時代のグラフィックスハードウェアは、ほとんどが設定可能な固定機能に制限されていたということです。プログラマーは頂点データを標準フォーマットで与えなければならず、ライティングやシェーディングのオプションに関してはGPUメーカーのなすがままでした。

グラフィックカードのアーキテクチャが進歩するにつれ、より多くのプログラマブルな機能が提供されるようになりました。このような新機能はすべて、何らかの方法で既存のAPIに統合する必要がありました。その結果、非現実的な抽象化が行われ、最新のグラフィックスアーキテクチャでは、プログラマーの意図を汲んで動作するために、グラフィックスドライバ側で多くの推測が必要になりました。そのため、ゲームのパフォーマンスを向上させるためのドライバのアップデートが非常に多く、その中には時に大きな性能の改善があったものもあったのです。これらのドライバは複雑であるため、アプリケーション開発者は、[シェーダ](https://ja.wikipedia.org/wiki/%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC)が受け付けるシンタックスの違いのような、ベンダー間の動作の違いにも対処しなければなりませんでした。これらの新機能とは別に、ここ10年で強力なグラフィックスハードウェアを搭載したモバイルデバイスが登場しました。これらのモバイルGPUは、エネルギーとスペースの要件に基づいて異なるアーキテクチャを持っています。例として、[タイルレンダリング](https://en.wikipedia.org/wiki/Tiled_rendering)がありますが、プログラマーがタイルレンダリングの機能をより多く制御できるようにすることで、パフォーマンスを向上させることができます。これらの時代のAPIに起因するもう1つの制限は、マルチスレッドのサポートが限られていることであり、CPU側がボトルネックになる可能性があります。

Vulkanは、最新のグラフィックスアーキテクチャのためにゼロから設計されているため、これらの問題を解決します。プログラマがより詳細なAPIを使用して意図を明確に指定できるようにすることでドライバのオーバーヘッドを削減し、複数のスレッドが並列にコマンドを作成して送信できるようにします。また、単一のコンパイラによる標準化されたバイトコードフォーマットを用いることで、シェーダのコンパイルにおける動作の違いを減らします。最後に、グラフィックス(描画処理)とコンピューティング(GPUによる数値計算)を単一のAPIに統一することで、最新のグラフィックスカードの汎用処理能力を高めます。

## 三角形を描画するために必要なこと

ここでは、行儀がよい(well-behavedの訳、メモリー操作などをOSを介して行ない,、ハードウェアを直接制御しないという意味)Vulkanプログラムで三角形をレンダリングするために必要なステップの概要を見てみましょう。ここで紹介したコンセプトはすべて次の章で詳しく説明します。これは、個々の手順を関連付けるための全体像を示しています。

### ステップ 1 - インスタンスと物理デバイスの選択

Vulkanアプリケーションでは、まず最初に、`VkInstance`によってVulkan APIをセットアップします。次にアプリケーションと使用するAPIエクステンションを記述することで、インスタンスを作成します。その後、Vulkanがサポートするハードウェアを問い合わせ、操作に使用する `VkPhysicalDevice` を1つまたは複数選びます。VRAMサイズやデバイスの機能などのプロパティを取得して、必要なデバイスを選択することができます。例えば、専用のグラフィックカードを選択することなどができます。

### ステップ 2 - 論理デバイスとキューファミリー

使用する適切なハードウェアデバイスを選択した後、VkDevice (論理デバイス) を作成する必要があります。ここでは、マルチビューポートレンダリングや 64 ビットフロートなど、どの VkPhysicalDeviceFeatures を使用するかをより具体的に記述します。また、使用したいキューファミリも指定する必要があります。描画コマンドやメモリ操作など、Vulkanで実行されるほとんどの操作は、VkQueueに送信することで非同期的に実行されます。キューはキューファミリから割り当てられ、各キューファミリはそのキューで特定の操作セットをサポートしています。例えば、グラフィックス、計算、メモリ転送の各操作のために、別々のキューファミリが存在することも考えられます。また、利用可能なキューファミリは、物理的なデバイス選択の際の識別要素にもなります。Vulkan をサポートしているデバイスがグラフィックス機能を提供しないこともあり得ますが、現在のVulkanをサポートしているすべてのグラフィックスカードは、一般的に、我々が使用するすべてのキュー操作をサポートしています。

### ステップ 3 - ウィンドウサーフェスとスワップチェイン

オフスクリーンレンダリングだけに興味があるのでなければ、レンダリングされた画像を表示するためのウィンドウを作成する必要があります。ウィンドウは、ネイティブプラットフォームAPIや[GLFW](http://www.glfw.org/)や[SDL](https://www.libsdl.org/)などのライブラリを使って作成することができます。このチュートリアルでは GLFW を使用しますが、それについては次の章で詳しく説明します。

実際にウィンドウにレンダリングするためには、さらに2つのコンポーネント、ウィンドウサーフェス(VkSurfaceKHR)とスワップチェーン (VkSwapchainKHR)が必要です。`KHR`という接尾辞に注意してください。これは、それらのオブジェクトがVulkanの拡張機能の一部であることを意味します。Vulkan API自体はプラットフォームに完全に依存しないため、標準化された ウィンドウマネージャと対話するためのWSI (Window System Interface)を必要とします。ウィンドウサーフェスは、ウィンドウにレンダリングするためのクロスプラットフォームの抽象化で、一般的には、例えばWindowsでは `HWND` のような、ネイティブのウィンドウハンドルへの参照を与えることでインスタンス化されます。幸いにも、GLFWライブラリにはこのようなプラットフォーム固有の詳細に対処する組み込み関数があります。

スワップチェーンはレンダーターゲットの集合体です。その基本的な目的は、現在レンダリングしている画像と現在画面に表示されている画像が異なることを保証することです。これは、完全にレンダリングされた画像のみを表示するために重要です。フレームを描画するたびに、スワップチェーンにレンダリング先の画像を提供してもらう必要があります。フレームの描画が終わると、画像はスワップチェーンに戻され、画面に表示されます。レンダーターゲットの数と完成した画像を画面に表示するための条件は、スワップチェインのセットアップに使用するモードによって異なります。現在一般的なモードは、ダブルバッファリング（vsync）とトリプルバッファリングです。これらについては、スワップチェーンの作成の章で説明します。

プラットフォームによっては、`VK_KHR_display` や `VK_KHR_display_swapchain`エクステンションを使用することで、ウィンドウマネージャと介することなくディスプレイに直接レンダリングすることができます。これらにより、画面全体を描画するサーフェスを作成することができ、例えば独自のウィンドウマネージャを実装するために使用することができます。

### ステップ 4 - イメージビューとフレームバッファ

スワップチェーンから取得した画像に描画するためには、VkImageViewとVkFramebufferにラップする必要があります。イメージビューは使用するイメージの特定の部分を参照し、フレームバッファはカラー、深度、ステンシルターゲットに使用するイメージビューを参照します。スワップチェーンには多くの異なるイメージが存在する可能性があるので、それぞれの画像に対してイメージビューとフレームバッファを先取りして作成し、描画時に適切なものを選択します。

### ステップ 5 - レンダーパス

Vulkanのレンダーパスは、レンダリング操作時に使用される画像の種類(どのように使用されるか、その内容がどのように扱われるべきか)を記述します。最初の三角形のレンダリングアプリケーションでは、単一の画像をカラーターゲットとして使用し、描画操作の直前に単色にクリアすることをVulkanに伝えます。レンダーパスは画像の種類を記述するだけですが、VkFramebufferは実際に特定の画像をこれらのスロットにバインドします。

### ステップ 6 - グラフィックスパイプライン

Vulkanのグラフィックスパイプラインは、VkPipelineオブジェクトを作成することでセットアップされます。ビューポートサイズやデプスバッファの動作など、グラフィックスカードの設定可能な状態と、VkShaderModuleオブジェクトを使ったプログラマブルな状態を記述します。VkShaderModuleオブジェクトは、シェーダバイトコードから作成されます。また、ドライバはパイプラインでどのレンダーターゲットが使用されるかを知るため、レンダーパスを参照します。

既存のAPIと比較して、Vulkanの最も特徴的な特徴の1つは、グラフィックスパイプラインのほとんどすべての設定を事前に行う必要があるということです。つまり、異なるシェーダに切り替えたり、頂点レイアウトをわずかに変更したい場合は、グラフィックスパイプラインを完全に作り直す必要があるということです。つまり、レンダリング操作に必要なさまざまな組み合わせのために、事前に多くの VkPipeline オブジェクトを作成しておく必要があります。ビューポートサイズやクリアカラーなどの基本的な設定だけを動的に変更することができます。また、すべての状態を明示的に記述する必要があり、例えばデフォルトのカラーブレンド状態はありません。

利点としては、先行コンパイルを行うことで、同等のことをジャストインタイムコンパイルで行うことに比べ、別のグラフィックパイプラインへの切り替えなどの大きな状態変化が非常に明確になるため、ドライバの最適化の機会が増え、ランタイムパフォーマンスがより予測可能になることです。

### ステップ 7 - コマンドプールとコマンドバッファ

前述したように、描画操作のような実行したいVulkanの操作の多くは、キューに投入する必要があります。これらの操作は、投入する前にまずVkCommandBufferに記録する必要があります。これらのコマンドバッファは、特定のキューファミリに関連付けられた `VkCommandPool` から割り当てられます。単純な三角形を描くために、以下の操作をコマンドバッファに記録する必要があります。

* レンダーパスの開始
* グラフィックスパイプラインのバインド
* 3つの頂点を描画
* レンダーパスの終了

フレームバッファ内のイメージは、スワップチェーンがどの特定のイメージを与えるかに依存するので、可能性のあるイメージごとにコマンドバッファを記録し、描画時に適切なイメージを選択する必要があります。別の方法としては、フレームごとにコマンドバッファを記録し直すことになりますが、これは効率的ではありません。

### ステップ 8 - メインループ

描画コマンドがコマンドバッファにラップされたので、メインループは非常に簡単です。まず、vkAcquireNextImageKHRでスワップチェーンからイメージを取得します。次に、その画像に適したコマンドバッファを選択し、vkQueueSubmit で実行します。最後に、vkQueuePresentKHR で画面に表示するために画像をスワップチェーンに戻します。

キューに投入された操作は非同期的に実行されます。そのため、セマフォのような同期オブジェクトを利用して、正しい実行順序を確保する必要があります。描画コマンドバッファの実行は、画像の取得が終了するのを待つように設定しなければなりません。そうしないと、画面に表示するためにまだ読み込まれている画像に対してレンダリングを開始してしまう可能性があります。vkQueuePresentKHRの呼び出しは、レンダリングが終了するのを待つ必要があります。そのためには、レンダリングが完了した後にシグナルが送られる2番目のセマフォを使用します。

### まとめ

この慌ただしいツアー(三角形を描画する手順の概要の説明)で、最初の三角形を描くための基本的な作業を理解していただけたと思います。実際のプログラムでは、頂点バッファの割り当て、ユニフォームバッファの作成、テクスチャ画像のアップロードなどのステップがありますが、Vulkanの学習曲線は急なので、ここでは簡単なものから始めます。頂点バッファを使用する代わりに、頂点座標を頂点シェーダに最初から埋め込むことで少しごまかしていることに注意してください。これは、頂点バッファを管理するには、まずコマンドバッファに慣れておく必要があるからです。

さて、最初の三角形を描画するために必要なことをまとめると以下のとおりです。

* VkInstanceの作成
* サポートされているグラフィックカード（VkPhysicalDevice）の選択
* 描画と表示のためのVkDeviceとVkQueueの作成
* ウィンドウ、ウィンドウサーフェス、スワップチェーンの作成
* スワップチェーンの画像をVkImageViewにラップ
* レンダーターゲットと用途を指定するレンダーパスの作成
* レンダーパスのためのフレームバッファの作成
* グラフィックスパイプラインのセットアップ
* 可能なスワップチェーンイメージごとにコマンドバッファを確保し描画コマンドを記録
* 画像を取得し正しい描画コマンドバッファを送信し、スワップチェーンに画像を戻すことでフレームを描画

たくさんのステップがありますが、それぞれのステップの目的は次からの章で非常にシンプルで明確になります。もし、プログラム全体に対する一つのステップの関係について混乱したならば、この章に戻ってきてください。

## APIのコンセプト

この章の最後に、Vulkan APIが低レベルでどのように構成されているかを簡単に説明します。

### コーディング規約

Vulkanの関数、列挙型、構造体はすべて `vulkan.h` ヘッダーで定義されており、LunarGが開発した[Vulkan SDK](https://lunarg.com/vulkan-sdk/)に含まれている。次の章では、このSDKのインストールについて見ていきます。

関数は小文字の `vk` 接頭辞を持ち、列挙や構造体のような型は `Vk` 接頭辞を持ち、列挙値は `VK_` 接頭辞を持ちます。APIでは、関数のパラメータを提供するために構造体を多用しています。例えば、オブジェクトの作成は一般的にこのパターンに従います。

```c++
VkXXXCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_XXX_CREATE_INFO;
createInfo.pNext = nullptr;
createInfo.foo = ...;
createInfo.bar = ...;

VkXXX object;
if (vkCreateXXX(&createInfo, nullptr, &object) != VK_SUCCESS) {
    std::cerr << "failed to create object" << std::endl;
    return false;
}
```

Vulkanの多くの構造体では、`sType`メンバで構造体の型を明示的に指定する必要があります。`pNext` メンバは拡張構造体を指すことができますが、このチュートリアルでは常に`nullptr`とします。オブジェクトを作成または破棄する関数は VkAllocationCallbacks パラメータを持ち、ドライバメモリ用のカスタムアロケータを使用することができますが、このチュートリアルでは`nullptr`のままにしておきます。

ほとんどすべての関数は `VK_SUCCESS` かエラーコードのいずれかである VkResult を返します。仕様書では、各関数が返すことができるエラーコードとその意味が説明されています。

### バリデーションレイヤー

前述したように、Vulkanは高性能でドライバのオーバーヘッドが少ないように設計されています。そのため、デフォルトでは非常に限られたエラーチェックやデバッグ機能のみが含まれています。何か間違ったことをした場合、ドライバはエラーコードを返さずにクラッシュしたり、最悪の場合、あなたのグラフィックカードでは動作しているように見えるが、他のカードでは完全に失敗することがよくあります。

Vulkanでは、*バリデーションレイヤー*と呼ばれる機能を使って広範囲のチェックを行うことができます。バリデーションレイヤーとは、APIとグラフィックスドライバの間に挿入することができるコードの断片で、関数パラメータの追加チェックやメモリ管理の問題の追跡などを行うことができます。良い点は、開発中にバリデーションレイヤーを有効にして、アプリケーションをリリースするときに完全に無効にすることができ、オーバーヘッドがゼロになることです。誰でも独自のバリデーションレイヤーを書くことができますが、LunarGのVulkan SDKは、バリデーションレイヤーの標準セットを提供しているため、このチュートリアルではそれを使用します。また、レイヤーからのデバッグメッセージを受信するために、コールバック関数を登録する必要があります。

Vulkanはすべての操作について非常に明示的で、バリデーションレイヤーが非常に広範囲に及ぶため、OpenGLやDirect3Dと比較して画面が黒くなる原因を見つけるのが実際には非常に簡単になります！

コードを書き始めるまでに、もう一つのステップがあります。それは[開発環境を構築](!ja/開発環境)することです。
